
; EPWM
EPWM1_BASE		.set	0x6800
TBPHSHR1		.set 	EPWM1_BASE+0x2
TBPHS1 			.set 	EPWM1_BASE+0x3
TBCTR1 			.set 	EPWM1_BASE+0x4
TBPRD1 			.set 	EPWM1_BASE+0x5
CMPAHR1			.set	EPWM1_BASE+0x8
CMPA1 			.set 	EPWM1_BASE+0x9
CMPB1 			.set 	EPWM1_BASE+0xA
DBRED1 			.set 	EPWM1_BASE+0x10
DBFED1 			.set 	EPWM1_BASE+0x11
TZSEL1 			.set 	EPWM1_BASE+0x12
TZCTL1 			.set 	EPWM1_BASE+0x14
TZEINT1 		.set 	EPWM1_BASE+0x15
TZFLG1 			.set 	EPWM1_BASE+0x16
TZCLR1 			.set 	EPWM1_BASE+0x17
TZFRC1 			.set 	EPWM1_BASE+0x18
ETSEL1 			.set 	EPWM1_BASE+0x19
ETPS1 			.set 	EPWM1_BASE+0x1A
ETFLG1 			.set 	EPWM1_BASE+0x1B
ETCLR1 			.set 	EPWM1_BASE+0x1C
ETFRC1 			.set 	EPWM1_BASE+0x1D

EPWM2_BASE		.set	0x6840
TBPHSHR2		.set 	EPWM2_BASE+0x2
TBPHS2 			.set 	EPWM2_BASE+0x3
TBCTR2 			.set 	EPWM2_BASE+0x4
TBPRD2 			.set 	EPWM2_BASE+0x5
CMPAHR2			.set	EPWM2_BASE+0x8
CMPA2 			.set 	EPWM2_BASE+0x9
CMPB2 			.set 	EPWM2_BASE+0xA
DBRED2			.set 	EPWM2_BASE+0x10
DBFED2 			.set 	EPWM2_BASE+0x11
TZSEL2 			.set 	EPWM2_BASE+0x12
TZCTL2 			.set 	EPWM2_BASE+0x14
TZEINT2 		.set 	EPWM2_BASE+0x15
TZFLG2 			.set 	EPWM2_BASE+0x16
TZCLR2 			.set 	EPWM2_BASE+0x17
TZFRC2 			.set 	EPWM2_BASE+0x18
ETSEL2 			.set 	EPWM2_BASE+0x19
ETPS2 			.set 	EPWM2_BASE+0x1A
ETFLG2 			.set 	EPWM2_BASE+0x1B
ETCLR2 			.set 	EPWM2_BASE+0x1C
ETFRC2 			.set 	EPWM2_BASE+0x1D

EPWM3_BASE		.set	0x6880
TBPHSHR3		.set 	EPWM3_BASE+0x2
TBPHS3 			.set 	EPWM3_BASE+0x3
TBCTR3 			.set 	EPWM3_BASE+0x4
TBPRD3 			.set 	EPWM3_BASE+0x5
CMPAHR3			.set	EPWM3_BASE+0x8
CMPA3 			.set 	EPWM3_BASE+0x9
CMPB3 			.set 	EPWM3_BASE+0xA
DBRED3 			.set 	EPWM3_BASE+0x10
DBFED3 			.set 	EPWM3_BASE+0x11
TZSEL3 			.set 	EPWM3_BASE+0x12
TZCTL3 			.set 	EPWM3_BASE+0x14
TZEINT3 		.set 	EPWM3_BASE+0x15
TZFLG3 			.set 	EPWM3_BASE+0x16
TZCLR3 			.set 	EPWM3_BASE+0x17
TZFRC3 			.set 	EPWM3_BASE+0x18
ETSEL3 			.set 	EPWM3_BASE+0x19
ETPS3 			.set 	EPWM3_BASE+0x1A
ETFLG3 			.set 	EPWM3_BASE+0x1B
ETCLR3 			.set 	EPWM3_BASE+0x1C
ETFRC3 			.set 	EPWM3_BASE+0x1D

EPWM4_BASE		.set	0x68C0
TBPHS4 			.set 	EPWM4_BASE+0x3
TBCTR4 			.set 	EPWM4_BASE+0x4
TBPRD4 			.set 	EPWM4_BASE+0x5
CMPAHR4			.set	EPWM4_BASE+0x8
CMPA4 			.set 	EPWM4_BASE+0x9
CMPB4 			.set 	EPWM4_BASE+0xA
DBRED4 			.set 	EPWM4_BASE+0x10
DBFED4 			.set 	EPWM4_BASE+0x11
TZSEL4 			.set 	EPWM4_BASE+0x12
TZCTL4 			.set 	EPWM4_BASE+0x14
TZEINT4 		.set 	EPWM4_BASE+0x15
TZFLG4 			.set 	EPWM4_BASE+0x16
TZCLR4 			.set 	EPWM4_BASE+0x17
TZFRC4 			.set 	EPWM4_BASE+0x18
ETSEL4 			.set 	EPWM4_BASE+0x19
ETPS4 			.set 	EPWM4_BASE+0x1A
ETFLG4 			.set 	EPWM4_BASE+0x1B
ETCLR4 			.set 	EPWM4_BASE+0x1C
ETFRC4 			.set 	EPWM4_BASE+0x1D

EPWM5_BASE		.set	0x6900
TBPHS5 			.set 	EPWM5_BASE+0x3
TBCTR5 			.set 	EPWM5_BASE+0x4
TBPRD5 			.set 	EPWM5_BASE+0x5
CMPA5 			.set 	EPWM5_BASE+0x9
CMPB5 			.set 	EPWM5_BASE+0xA
DBRED5 			.set 	EPWM5_BASE+0x10
DBFED5 			.set 	EPWM5_BASE+0x11

EPWM6_BASE		.set	0x6940
TBPHS6 			.set 	EPWM6_BASE+0x3
TBCTR6 			.set 	EPWM6_BASE+0x4
TBPRD6 			.set 	EPWM6_BASE+0x5
CMPA6			.set 	EPWM6_BASE+0x9
CMPB6 			.set 	EPWM6_BASE+0xA
DBRED6 			.set 	EPWM6_BASE+0x10
DBFED6 			.set 	EPWM6_BASE+0x11
TZSEL6 			.set 	EPWM6_BASE+0x12
TZCTL6 			.set 	EPWM6_BASE+0x14
TZEINT6 		.set 	EPWM6_BASE+0x15
TZFLG6 			.set 	EPWM6_BASE+0x16
TZCLR6			.set 	EPWM6_BASE+0x17
TZFRC6 			.set 	EPWM6_BASE+0x18
ETSEL6 			.set 	EPWM6_BASE+0x19
ETPS6 			.set 	EPWM6_BASE+0x1A
ETFLG6 			.set 	EPWM6_BASE+0x1B
ETCLR6 			.set 	EPWM6_BASE+0x1C
ETFRC6 			.set 	EPWM6_BASE+0x1D

; ADC
ADCTRL1 		.set 	0x7100
ADCTRL2			.set 	0x7101
ADCTRL3			.set 	0x7118
ADCMAXCONV		.set	0x7102
ADCASEQSR		.set	0x7107
ADCREFSEL		.set	0x711C
ADCOFFTRIM		.set	0x711D
ADCCHSELSEQ1	.set	0x7103
ADCCHSELSEQ2	.set	0x7104
ADCCHSELSEQ3	.set	0x7105
ADCCHSELSEQ4	.set	0x7106
ADCST 			.set 	0x7119
INT_SEQ1_CLR 	.set 	0x0010

ADCRESULT0 		.set 	0x7108
ADCRESULT1 		.set 	0x7109
ADCRESULT2 		.set 	0x710A
ADCRESULT3 		.set 	0x710B
ADCRESULT4 		.set 	0x710C
ADCRESULT5 		.set 	0x710D
ADCRESULT6 		.set 	0x710E
ADCRESULT7 		.set 	0x710F
ADCRESULT8 		.set 	0x7110
ADCRESULT9 		.set 	0x7111
ADCRESULT10 	.set 	0x7112
ADCRESULT11 	.set 	0x7113
ADCRESULT12 	.set 	0x7114
ADCRESULT13 	.set 	0x7115
ADCRESULT14 	.set 	0x7116
ADCRESULT15 	.set 	0x7117

ADCPF0R0 		.set 	0x0B00
ADCPF0R1 		.set 	0x0B01
ADCPF0R2 		.set 	0x0B02
ADCPF0R3 		.set 	0x0B03
ADCPF0R4 		.set 	0x0B04
ADCPF0R5 		.set 	0x0B05
ADCPF0R6 		.set 	0x0B06
ADCPF0R7 		.set 	0x0B07
ADCPF0R8 		.set 	0x0B08
ADCPF0R9 		.set 	0x0B09
ADCPF0R10 		.set 	0x0B0A
ADCPF0R11 		.set 	0x0B0B
ADCPF0R12 		.set 	0x0B0C
ADCPF0R13 		.set 	0x0B0D
ADCPF0R14 		.set 	0x0B0E
ADCPF0R15 		.set 	0x0B0F

; Interrupts
PIEACK 			.set 	0x0CE1
PIEACK_GROUP1   .set	0x0001
PIEACK_GROUP2   .set 	0x0002
PIEACK_GROUP3   .set 	0x0004
PIEACK_GROUP4   .set 	0x0008
PIEACK_GROUP5   .set 	0x0010
PIEACK_GROUP6   .set 	0x0020
PIEACK_GROUP7   .set 	0x0040
PIEACK_GROUP8   .set 	0x0080
PIEACK_GROUP9   .set 	0x0100
PIEACK_GROUP10  .set 	0x0200
PIEACK_GROUP11  .set 	0x0400
PIEACK_GROUP12  .set 	0x0800

; GPIO Port A
GPAMUX1 		.set 	0x6F86
GPAMUX2 		.set 	0x6F88
GPADIR 			.set 	0x6F8A
GPADAT			.set 	0x6FC0
GPASET 			.set 	0x6FC2
GPACLEAR		.set 	0x6FC4
GPATOGGLE		.set 	0x6FC6

; GPIO Port B
GPBMUX1 		.set 	0x6F96
GPBDIR 			.set 	0x6F9A
GPBDAT			.set 	0x6FC8
GPBSET 			.set 	0x6FCA
GPBCLEAR		.set 	0x6FCC
GPBTOGGLE		.set 	0x6FCE


CONTEXT_SAVE 	.macro		
			PUSH AR1H:AR0H ; 32-bit
			PUSH XAR2 ; 32-bit
			PUSH XAR3 ; 32-bit
			PUSH XAR4 ; 32-bit
			PUSH XAR5 ; 32-bit
			PUSH XAR6 ; 32-bit
			PUSH XAR7 ; 32-bit
			PUSH XT ; 32-bit
		.endm
		
CONTEXT_REST		.macro
			POP XT
			POP XAR7
			POP XAR6
			POP XAR5
			POP XAR4
			POP XAR3
			POP XAR2
			POP AR1H:AR0H
		.endm





;==========================
ADC2CONT_DRV_INIT	.macro
;==========================
; Variable Definitions
_ADC2CH_Rslt		.usect "ADC2CH_CONT_DRV_Data",2,1,1		; Output Terminal 1

;Publish Terminal Pointers for access from the C environment (optional)
;======================================================================
					.def 	_ADC2CH_Rslt

		; actual macro code starts here
		; set terminal to point to ZeroNet
			MOVL	XAR2, #DummyNet
			MOVW	DP, #_ADC2CH_Rslt
			MOVL	@_ADC2CH_Rslt, XAR2
					.endm

;=========================
ADC2CONT_DRV	.macro		;8 cycles
;=========================
; uses PF0 (0WS mem)
			MOVW	DP, #_ADC2CH_Rslt
			MOVL 	XAR4,@_ADC2CH_Rslt		; XAR4: pointer to Net Bus

			MOVW	DP,#ADCPF0R0>>6
			MOVL 	XAR2,#ADCPF0R0			; XAR2: pointer to ADC buffer regs

; Read Result0 (1st conversion)
			MOV 	ACC,*XAR2++
			MOV 	*XAR4++,AL				; Q12 format, Unipolar input

; Read Result1 (2nd conversion)		
			MOV 	ACC,*XAR2++
			MOV 	*XAR4++,AL				; Q12 format, Unipolar input

; Read Result1 (2nd conversion)		
			MOV 	ACC,*XAR2++
			MOV 	*XAR4++,AL				; Q12 format, Unipolar input
					.endm


SINGEN_1CH_INIT	.macro x
;=======================
; Refer to sine table
                		.ref    SINTAB_360

; Constant Definitions
SIN_FREQ_MAX			.set   	0x1000				; Q15 

; Variable Definitions
_SINGEN_1CH_Gain:x:		.usect "SINGEN_data",2,1,1	; Input Terminal 1
_SINGEN_1CH_Offset:x:	.usect "SINGEN_data",2 		; Input Terminal 2
_SINGEN_1CH_Freq:x:		.usect "SINGEN_data",2 		; Input Terminal 3
_SINGEN_1CH_Out:x:		.usect "SINGEN_data",2 		; Output Terminal
SINGEN_1CH_Alpha:x:		.usect "SINGEN_data",1 		; Local Memory (history)
SINGEN_1CH_Fmax:x:		.usect "SINGEN_data",1 		; Local Memory


;Publish Terminal Pointers for access from the C environment (optional)
;======================================================================
					.def 	_SINGEN_1CH_Gain:x:				
					.def 	_SINGEN_1CH_Offset:x:
					.def 	_SINGEN_1CH_Freq:x:
					.def 	_SINGEN_1CH_Out:x:

		; actual macro code starts here
			MOVW	DP, #_SINGEN_1CH_Gain:x:
			MOV		@_SINGEN_1CH_Gain:x:, #0
			MOV		@(_SINGEN_1CH_Gain:x:+1), #0
			MOV		@_SINGEN_1CH_Offset:x:, #0
			MOV		@(_SINGEN_1CH_Offset:x:+1), #0
			MOV		@_SINGEN_1CH_Freq:x:, #0
			MOV		@(_SINGEN_1CH_Freq:x:+1), #0
			MOV		@_SINGEN_1CH_Out:x:, #0
			MOV		@(_SINGEN_1CH_Out:x:+1), #0
			MOV		@SINGEN_1CH_Fmax:x:, #SIN_FREQ_MAX
			MOV		@SINGEN_1CH_Alpha:x:, #0
				.endm

;=======================
SINGEN_1CH		.macro x
;=======================
			MOVW	DP, #_SINGEN_1CH_Gain:x:
			MOVL 	XAR2,@_SINGEN_1CH_Gain:x:	; Net pointer to Gain (XAR2)
			MOVL 	XAR3,@_SINGEN_1CH_Offset:x:	; Net pointer to Offset (XAR3)
			MOVL 	XAR4,@_SINGEN_1CH_Freq:x:	; Net pointer to Freq (XAR4)
			MOVL 	XAR5,@_SINGEN_1CH_Out:x:	; Net pointer to Out (XAR5)

	.if(!NET_DEBUG) ; i.e. normal operation

            SETC    SXM,OVM
                            
; Obtain the step value in pro-rata with the freq input         
            MOV     T,@SINGEN_1CH_Fmax:x:	; T = step_max (i.e. Freq max)
            MPY     ACC,T,*XAR4		   		; ACC = Freq*step_max
            MOVH    AL,ACC<<1           
            
; Increment the angle "alpha" by step value             
            ADD     AL,@SINGEN_1CH_Alpha:x:	; AL=(freq*step_max)+alpha  (Q0)
            MOV     @SINGEN_1CH_Alpha:x:,AL	; alpha=alpha+step

; Obtain the SIN of the angle "X=alpha" using direct Look-up Table            
            MOVL    XAR6,#SINTAB_360	;XAR5->SINTAB_360
            MOVB    XAR0,#0         
            MOVB    AR0,AL.MSB      	; AR0=indice (alpha/2^8)
            MOV     T,*+XAR6[AR0]   	; T=Y=*(SINTAB_360 + index)

; Scale the SIN output with the gain and add offset           
            MPY     ACC,T,*XAR2			; ACC=Y=SineValue * Gain
            LSL     ACC,#1          	; ACC=Y (Q31)
            ADD     ACC,*XAR3<<16 		; ACC=Y + Offset
            MOV     *XAR5,AH	    	; Out=Y*Gain+Offset
        	CLRC 	OVM

	.endif ; !NET_DEBUG


	; Used for debug only - checks module connectivity.
	.if(NET_DEBUG)
			MOV 	ACC,*XAR2			; mov Gain directly to Out
			MOV		*XAR5, AL			;  i.e. "Gain" to "Out" bypass
	.endif ; NET_DEBUG
			.endm


;====================================
CNTL_PI_V2_INIT	.macro x
;====================================
; Variable Declarations
;------------------------------------------------------------------------------
; Input, output pointers: 
; Pointers are 32-bits wide on the 28xx CPU - thus there need to be 2 words 
; of storage per pointer 
;------------------------------------------------------------------------------
_CNTL_PI_Ref:x:		.usect "CNTL_PI_Data:x:",2 	; Space for the input ptr
_CNTL_PI_Fdbk:x:	.usect "CNTL_PI_Data:x:",2 	; Space for the feedback ptr
_CNTL_PI_Coeff:x:	.usect "CNTL_PI_Data:x:",2 	; Space for the feedback ptr
_CNTL_PI_Out:x:		.usect "CNTL_PI_Data:x:",2 	; Space for the output ptr
_CNTL_PI_DBUFF:x: 	.usect "CNTL_PI_Data:x:",7	; "Local" memory (history) 
_CNTL_filler:x:     .usect "CNTL_PI_Data:x:",1	; "Local" memory (history) 
CNTL_PI_temp:x:     .usect "CNTL_PI_Data:x:",2	; "Local" memory (history) 

;Publish Terminal Pointers for access from the C environment (optional)
			.def 	_CNTL_PI_Ref:x:
			.def 	_CNTL_PI_Fdbk:x:
			.def 	_CNTL_PI_Out:x:
			.def 	_CNTL_PI_Coeff:x:

		; set terminal to point to ZeroNet
			MOVL	XAR2, #ZeroNet
			MOVW	DP, #_CNTL_PI_Ref:x:
			MOVL	@_CNTL_PI_Ref:x:, XAR2
			MOVL	@_CNTL_PI_Fdbk:x:, XAR2
			MOVL	@_CNTL_PI_Coeff:x:, XAR2
			MOVL	XAR2, #DummyNet
			MOVL	@_CNTL_PI_Out:x:, XAR2

		; Zero the Data Buffer
			MOVL 	XAR2,#_CNTL_PI_DBUFF:x:		; Point XAR2 to the buffer
			RPT		#5 								; Repeat 6 times
			||MOV	*XAR2++, #0						; write 0s to the buffer.

				.endm

;========================
CNTL_PI_V2	.macro x
;========================
			MOVW	DP, #_CNTL_PI_Ref:x:
			MOVL 	XAR4,@_CNTL_PI_Ref:x:		; Net pointer to Ref (XAR4)
			MOVL 	XAR5,@_CNTL_PI_Fdbk:x:		; Net pointer to Fdbk (XAR5)
			MOVL 	XAR6,@_CNTL_PI_Out:x:		; Net pointer to Out (XAR6)
			MOVL    XAR7,@_CNTL_PI_Coeff:x:		; Local coefficient pointer (XAR7)

			SETC    SXM,OVM 
			MOV 	ACC,*XAR4					;Q15

			SUB		ACC,*XAR5					;Q15-Q15

			MOV		T,	ACC
			MPY		ACC,T,#0x2000				;Q15+13=Q28

; Diff equation
			MOVL	@_CNTL_PI_DBUFF:x:+0, ACC	; Store the error  Q28
		
			MOVL 	XT,@_CNTL_PI_DBUFF:x:+0		; XT=E(n)	Q28
			ADDB	XAR7, #0x04					; Ki Q26 Increment AR7 to point to Ki
			QMPYL	P, XT, *XAR7				; Ki*E(n)  Q26*Q28=Q54-->(left high 32bit)Q22
			MOVL	ACC,@_CNTL_PI_DBUFF:x:+2	; Load integral I(n-1)  Q22  
			ADDL	ACC, P						; I(n) Q22 Add new product - ACC now has the new integral  
												; I(n)=Ki*E(n)+I(n-1) Q22
			SUBB	XAR7, #0x04					; IsatU Decrement AR7 to point back to IsatU
			MOVL	@_CNTL_PI_DBUFF:x:+4, ACC	; Store new integral in temp storage
			MINL	ACC, *XAR7++  				; if {ACC<=IsatU} ACC=unchanged
			MAXL	ACC, *XAR7++									; if {ACC>IsatU}  ACC=IsatU	
			MOVL	@_CNTL_PI_DBUFF:x:+4, ACC									;	Get the Minimum of the upper limit or the
			ADDB	XAR7, #0x02					; Kp Q26 Increment AR7 to point to Kp
			MOVL 	XT,@_CNTL_PI_DBUFF:x:+0		; XT=E(n)	Q28			
			QMPYL	P, XT, *XAR7				; P=Kp*E(n) Q26*Q28=Q54-->Q22  Compute
			ADDL	ACC,	P					; Q22
						
			ADDB	XAR7, #0x04
			MINL	ACC, *XAR7++  				; Get the Minimum of the upper limit or the
												; new control output - saturation on upper side.
			MAXL	ACC, *XAR7++				; Get the maximum of the lower limit or the 
												; new control output - saturation on the lower side.
			ASR64	ACC:P, #7					; Q22-7=Q15
			MOV		*XAR6, ACC					; Store new control output  Q15		
		
			MOVL	ACC,@_CNTL_PI_DBUFF:x:+4	; Load temporary integral storage Q25
			MOVL	@_CNTL_PI_DBUFF:x:+2, ACC   ; NTC Q20	
			.endm
;=================================================================================
;	HRFULLBDG_BIPOLAR_DRV  driver module - Hi Res Full-Bridge Converter uing Bipolar 
;                                          PWM scheme s/w driver
;=================================================================================
;			________________________
;			| HRFULLBDG_BIPOLAR_DRV |
;			|~~~~~~~~~~~~~~~~~~~~~~~|
;		 	|	   		     EPWM1A |--> HiRes capable output
;		 -->| In (Q15)	     EPWM1B |--> HiRes capable output
;		 	|		  	     EPWM2A |--> HiRes capable output
;		 	|		  	     EPWM2B |--> HiRes capable output
;			|_______________________|
;
;   Note: Input is in a range of (-1,1). 
;
;	In, is a pointer to signal nets.
;   Peripheral Resources used: EPWM1/2+HR module
;
; Description:
; ------------
; HiRes Bipolar Full-Bridge converter peripheral Driver interface
;
;=================================================================================
;=============================
HRFULLBDG_BIPOLAR_DRV_INIT		.macro
;=============================
; Variable Declarations
_HRFullBdg_BI_In	.usect "Net_terminals",2,1,1	; Input Terminal 1
_SFFullBdg_BI		.usect "Net_terminals",1 		; HR Full-Bridge Scale factor
hrfullbdg_bi_period	.usect "Net_terminals",1 		; HR Full-Bridge period value

;Publish Terminal Pointers for access from the C environment
;===========================================================
					.def 	_HRFullBdg_BI_In
					.def 	_SFFullBdg_BI

		; set terminal to point to ZeroNet
			MOVL	XAR2, #ZeroNet
			MOVW	DP, #_HRFullBdg_BI_In
			MOVL	@_HRFullBdg_BI_In, XAR2

			MOVW 	DP,#TBPRD1>>6
			MOV		ACC, @TBPRD1
			;MOV		ACC, #0x700
			MOVW	DP,#hrfullbdg_bi_period
			MOV		@hrfullbdg_bi_period, ACC   ; hrfullbdg_bi_period = TBPRD
		; This is the start value only
			MOV		@_SFFullBdg_BI, #(66*256)  ; Initial value for 100MHz case
					.endm

;=========================
HRFULLBDG_BIPOLAR_DRV		.macro
;=========================
			MOVW	DP, #_HRFullBdg_BI_In
			MOVL 	XAR2,@_HRFullBdg_BI_In		; Net pointer for In  (XAR2)
			MOVL 	XAR3,#CMPA1		
			MOVL 	XAR4,#CMPA2
			
			SETC    SXM,OVM
		; Outputs for EPWM1A and EPWM2A (Hi Res)		
			MOV 	T,*XAR2
			MPY 	ACC,T,#680       ; ACC = Duty*TBPRD*m  (Q15) , max<=(TBPRD-2*Tdead)/TBPRD to invoid dead time making D lost
            ADD     ACC,@hrfullbdg_bi_period<<15     ; ACC = Duty*TBPRD + TBPRD  (Q15)
			;MOV		T,@_SFFullBdg_BI
			;MPYU	P,T,@AL                 ; P = T * AL
			;MOVH	@AL,P
			;ADD		ACC, #0x17F				; Optimize by Round up
			;LSL		ACC,	#1
			MOV 	*XAR3,	AH 				; CMP1A:CMPAHR1(31:8) = ACC
            MOV   	*XAR4,	AH               ; CMP2A:CMPAHR2(31:8) = ACC

				.endm
				
;=================================================================================
;	HRFULLBDG_UNIPOLAR1_DRV  driver module - Hi Res Full-Bridge Converter uing Unipolar 
;                                          PWM scheme 1 s/w driver
;=================================================================================
;			__________________________
;			| HRFULLBDG_UNIPOLAR1_DRV |
;			|~~~~~~~~~~~~~~~~~~~~~~~~~|
;		 	|	   		       EPWM1A |--> HiRes capable output
;		 -->| In (Q15)	       EPWM1B |--> HiRes capable output
;		    |                  EPWM2A |--> HiRes capable output
;		 	|		  	       EPWM2B |--> HiRes capable output
;			|_________________________|
;
;   Note: Input is in a range of (-1,1). 
;
;	In, is a pointer to signal nets.
;   Peripheral Resources used: EPWM1/2+HR module
;
; Description:
; ------------
; HiRes Unipolar1 Full-Bridge converter peripheral Driver interface
;
;=================================================================================
;=============================
HRFULLBDG_UNIPOLAR1_DRV_INIT		.macro
;=============================
; Variable Declarations
_HRFullBdg_UNI1_In	       .usect "Net_terminals",2,1,1	    ; Input Terminal 1
_SFFullBdg_UNI1		       .usect "Net_terminals",1 		; HR Full-Bridge Scale factor
hrfullbdg_uni1_period  	   .usect "Net_terminals",1 		; HR Full-Bridge period value

;Publish Terminal Pointers for access from the C environment
;===========================================================
					.def 	_HRFullBdg_UNI1_In
					.def 	_SFFullBdg_UNI1

		; set terminal to point to ZeroNet
			MOVL	XAR2, #ZeroNet
			MOVW	DP, #_HRFullBdg_UNI1_In
			MOVL	@_HRFullBdg_UNI1_In, XAR2

			MOVW 	DP,#TBPRD1>>6
			MOV		ACC, @TBPRD1
			MOVW	DP,#hrfullbdg_uni1_period
			MOV		@hrfullbdg_uni1_period, ACC   ; hrfullbdg_uni1_period = TBPRD
		; This is the start value only
			MOV		@_SFFullBdg_UNI1, #(66*256)  ; Initial value for 100MHz case
					.endm

;=========================
HRFULLBDG_UNIPOLAR1_DRV		.macro
;=========================
			MOVW	DP, #_HRFullBdg_UNI1_In
			MOVL 	XAR2,@_HRFullBdg_UNI1_In		    ; Net pointer for In  (XAR2)
			MOVL 	XAR3,#CMPAHR1		
			;MOVL 	XAR4,#CMPAHR2

		; Outputs for EPWM1A and EPWM2A (Hi Res)		
			MOVW	DP, #_HRFullBdg_UNI1_In
			MOV 	T,*XAR2
			MPY 	ACC,T,@hrfullbdg_uni1_period       ; ACC = Duty*TBPRD  (Q15)
            ADD     ACC,@hrfullbdg_uni1_period<<15     ; ACC = Duty*TBPRD + TBPRD  (Q15)
			MOV		T,@_SFFullBdg_UNI1
			MPYU	P,T,@AL                 ; P = T * AL
			MOVH	@AL,P
			ADD		ACC, #0x17F				; Optimize by Round up
			MOVL	*XAR3,ACC 				; CMP1A:CMPAHR1(31:8) = ACC
            ;MOVL    *XAR4,ACC               ; CMP2A:CMPAHR2(31:8) = ACC
   
				.endm
