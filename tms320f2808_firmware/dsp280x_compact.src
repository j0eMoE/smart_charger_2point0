!<arch>
<filenames>/    0           1     0     0       365       `

DSP280x_GlobalVariableDefs.asm/
DSP280x_GlobalVariableDefs.c/
DSP280x_CodeStartBranch.asm/
DSP280x_CSMPasswords.asm/
DSP280x_DBGIER.asm/
DSP280x_DisInt.asm/
DSP280x_usDelay.asm/
DSP280x_CpuTimers.c/
DSP280x_DefaultIsr.c/
DSP280x_MemCopy.c/
DSP280x_PieCtrl.c/
DSP280x_PieVect.c/
DSP280x_SWPrioritizedDefaultIsr.c/
DSP280x_SWPrioritizedPieVect.c/
DSP280x_SysCtrl.c/

DSP280x_GlobalV/1129227558  1     0     0       88899     `
;***************************************************************
;* TMS320C2000 C/C++ Codegen                   PC Version 3.11 *
;* Date/Time created: Thu Oct 13 13:19:18 2005                 *
;***************************************************************
FP	.set	XAR2
	.file	"DSP280x_GlobalVariableDefs.c"
	.global	_CpuTimer2Regs
_CpuTimer2Regs:	.usect	"CpuTimer2RegsFile",8,1,1
	.sym	_CpuTimer2Regs,_CpuTimer2Regs, 8, 2, 128, _CPUTIMER_REGS
	.global	_CpuTimer1Regs
_CpuTimer1Regs:	.usect	"CpuTimer1RegsFile",8,1,1
	.sym	_CpuTimer1Regs,_CpuTimer1Regs, 8, 2, 128, _CPUTIMER_REGS
	.global	_FlashRegs
_FlashRegs:	.usect	"FlashRegsFile",8,1,0
	.sym	_FlashRegs,_FlashRegs, 8, 2, 128, _FLASH_REGS
	.global	_CpuTimer0Regs
_CpuTimer0Regs:	.usect	"CpuTimer0RegsFile",8,1,1
	.sym	_CpuTimer0Regs,_CpuTimer0Regs, 8, 2, 128, _CPUTIMER_REGS
	.global	_CsmPwl
_CsmPwl:	.usect	"CsmPwlFile",8,1,0
	.sym	_CsmPwl,_CsmPwl, 8, 2, 128, _CSM_PWL
	.global	_GpioIntRegs
_GpioIntRegs:	.usect	"GpioIntRegsFile",10,1,1
	.sym	_GpioIntRegs,_GpioIntRegs, 8, 2, 160, _GPIO_INT_REGS
	.global	_SpicRegs
_SpicRegs:	.usect	"SpicRegsFile",16,1,0
	.sym	_SpicRegs,_SpicRegs, 8, 2, 256, _SPI_REGS
	.global	_SpibRegs
_SpibRegs:	.usect	"SpibRegsFile",16,1,0
	.sym	_SpibRegs,_SpibRegs, 8, 2, 256, _SPI_REGS
	.global	_ScibRegs
_ScibRegs:	.usect	"ScibRegsFile",16,1,0
	.sym	_ScibRegs,_ScibRegs, 8, 2, 256, _SCI_REGS
	.global	_SpiaRegs
_SpiaRegs:	.usect	"SpiaRegsFile",16,1,0
	.sym	_SpiaRegs,_SpiaRegs, 8, 2, 256, _SPI_REGS
	.global	_SciaRegs
_SciaRegs:	.usect	"SciaRegsFile",16,1,0
	.sym	_SciaRegs,_SciaRegs, 8, 2, 256, _SCI_REGS
	.global	_CsmRegs
_CsmRegs:	.usect	"CsmRegsFile",16,1,0
	.sym	_CsmRegs,_CsmRegs, 8, 2, 256, _CSM_REGS
	.global	_AdcMirror
_AdcMirror:	.usect	"AdcMirrorFile",16,1,0
	.sym	_AdcMirror,_AdcMirror, 8, 2, 256, _ADC_RESULT_MIRROR_REGS
	.global	_SpidRegs
_SpidRegs:	.usect	"SpidRegsFile",16,1,0
	.sym	_SpidRegs,_SpidRegs, 8, 2, 256, _SPI_REGS
	.global	_XIntruptRegs
_XIntruptRegs:	.usect	"XIntruptRegsFile",16,1,0
	.sym	_XIntruptRegs,_XIntruptRegs, 8, 2, 256, _XINTRUPT_REGS
	.global	_PieCtrlRegs
_PieCtrlRegs:	.usect	"PieCtrlRegsFile",26,1,0
	.sym	_PieCtrlRegs,_PieCtrlRegs, 8, 2, 416, _PIE_CTRL_REGS
	.global	_AdcRegs
_AdcRegs:	.usect	"AdcRegsFile",30,1,0
	.sym	_AdcRegs,_AdcRegs, 8, 2, 480, _ADC_REGS
	.global	_ECap4Regs
_ECap4Regs:	.usect	"ECap4RegsFile",32,1,1
	.sym	_ECap4Regs,_ECap4Regs, 8, 2, 512, _ECAP_REGS
	.global	_ECap2Regs
_ECap2Regs:	.usect	"ECap2RegsFile",32,1,1
	.sym	_ECap2Regs,_ECap2Regs, 8, 2, 512, _ECAP_REGS
	.global	_ECap3Regs
_ECap3Regs:	.usect	"ECap3RegsFile",32,1,1
	.sym	_ECap3Regs,_ECap3Regs, 8, 2, 512, _ECAP_REGS
	.global	_ECap1Regs
_ECap1Regs:	.usect	"ECap1RegsFile",32,1,1
	.sym	_ECap1Regs,_ECap1Regs, 8, 2, 512, _ECAP_REGS
	.global	_GpioDataRegs
_GpioDataRegs:	.usect	"GpioDataRegsFile",32,1,1
	.sym	_GpioDataRegs,_GpioDataRegs, 8, 2, 512, _GPIO_DATA_REGS
	.global	_SysCtrlRegs
_SysCtrlRegs:	.usect	"SysCtrlRegsFile",32,1,0
	.sym	_SysCtrlRegs,_SysCtrlRegs, 8, 2, 512, _SYS_CTRL_REGS
	.global	_I2caRegs
_I2caRegs:	.usect	"I2caRegsFile",34,1,0
	.sym	_I2caRegs,_I2caRegs, 8, 2, 544, _I2C_REGS
	.global	_EPwm1Regs
_EPwm1Regs:	.usect	"EPwm1RegsFile",34,1,1
	.sym	_EPwm1Regs,_EPwm1Regs, 8, 2, 544, _EPWM_REGS
	.global	_EPwm2Regs
_EPwm2Regs:	.usect	"EPwm2RegsFile",34,1,1
	.sym	_EPwm2Regs,_EPwm2Regs, 8, 2, 544, _EPWM_REGS
	.global	_EPwm3Regs
_EPwm3Regs:	.usect	"EPwm3RegsFile",34,1,1
	.sym	_EPwm3Regs,_EPwm3Regs, 8, 2, 544, _EPWM_REGS
	.global	_EPwm5Regs
_EPwm5Regs:	.usect	"EPwm5RegsFile",34,1,1
	.sym	_EPwm5Regs,_EPwm5Regs, 8, 2, 544, _EPWM_REGS
	.global	_EPwm4Regs
_EPwm4Regs:	.usect	"EPwm4RegsFile",34,1,1
	.sym	_EPwm4Regs,_EPwm4Regs, 8, 2, 544, _EPWM_REGS
	.global	_EPwm6Regs
_EPwm6Regs:	.usect	"EPwm6RegsFile",34,1,1
	.sym	_EPwm6Regs,_EPwm6Regs, 8, 2, 544, _EPWM_REGS
	.global	_ECanaRegs
_ECanaRegs:	.usect	"ECanaRegsFile",52,1,1
	.sym	_ECanaRegs,_ECanaRegs, 8, 2, 832, _ECAN_REGS
	.global	_ECanbRegs
_ECanbRegs:	.usect	"ECanbRegsFile",52,1,1
	.sym	_ECanbRegs,_ECanbRegs, 8, 2, 832, _ECAN_REGS
	.global	_ECanbLAMRegs
_ECanbLAMRegs:	.usect	"ECanbLAMRegsFile",64,1,1
	.sym	_ECanbLAMRegs,_ECanbLAMRegs, 8, 2, 1024, _LAM_REGS
	.global	_ECanaMOTORegs
_ECanaMOTORegs:	.usect	"ECanaMOTORegsFile",64,1,1
	.sym	_ECanaMOTORegs,_ECanaMOTORegs, 8, 2, 1024, _MOTO_REGS
	.global	_ECanaLAMRegs
_ECanaLAMRegs:	.usect	"ECanaLAMRegsFile",64,1,1
	.sym	_ECanaLAMRegs,_ECanaLAMRegs, 8, 2, 1024, _LAM_REGS
	.global	_ECanaMOTSRegs
_ECanaMOTSRegs:	.usect	"ECanaMOTSRegsFile",64,1,1
	.sym	_ECanaMOTSRegs,_ECanaMOTSRegs, 8, 2, 1024, _MOTS_REGS
	.global	_GpioCtrlRegs
_GpioCtrlRegs:	.usect	"GpioCtrlRegsFile",64,1,1
	.sym	_GpioCtrlRegs,_GpioCtrlRegs, 8, 2, 1024, _GPIO_CTRL_REGS
	.global	_ECanbMOTORegs
_ECanbMOTORegs:	.usect	"ECanbMOTORegsFile",64,1,1
	.sym	_ECanbMOTORegs,_ECanbMOTORegs, 8, 2, 1024, _MOTO_REGS
	.global	_EQep1Regs
_EQep1Regs:	.usect	"EQep1RegsFile",64,1,1
	.sym	_EQep1Regs,_EQep1Regs, 8, 2, 1024, _EQEP_REGS
	.global	_ECanbMOTSRegs
_ECanbMOTSRegs:	.usect	"ECanbMOTSRegsFile",64,1,1
	.sym	_ECanbMOTSRegs,_ECanbMOTSRegs, 8, 2, 1024, _MOTS_REGS
	.global	_EQep2Regs
_EQep2Regs:	.usect	"EQep2RegsFile",64,1,1
	.sym	_EQep2Regs,_EQep2Regs, 8, 2, 1024, _EQEP_REGS
	.global	_DevEmuRegs
_DevEmuRegs:	.usect	"DevEmuRegsFile",208,1,1
	.sym	_DevEmuRegs,_DevEmuRegs, 8, 2, 3328, _DEV_EMU_REGS
	.global	_PieVectTable
_PieVectTable:	.usect	"PieVectTableFile",256,1,1
	.sym	_PieVectTable,_PieVectTable, 8, 2, 4096, _PIE_VECT_TABLE
	.global	_ECanbMboxes
_ECanbMboxes:	.usect	"ECanbMboxesFile",256,1,1
	.sym	_ECanbMboxes,_ECanbMboxes, 8, 2, 4096, _ECAN_MBOXES
	.global	_ECanaMboxes
_ECanaMboxes:	.usect	"ECanaMboxesFile",256,1,1
	.sym	_ECanaMboxes,_ECanaMboxes, 8, 2, 4096, _ECAN_MBOXES
;	C:\ti\c2000\cgtools_311\bin\opt2000.exe -m -v28 -s -O2 -Z C:\DOCUME~1\A0323024\LOCALS~1\Temp\TI4032_2 C:\DOCUME~1\A0323024\LOCALS~1\Temp\TI4032_5 -w ../obj 
;	C:\ti\c2000\cgtools_311\bin\ac2000.exe -@C:\DOCUME~1\A0323024\LOCALS~1\Temp\TI4032_4 

;***************************************************************
;* TYPE INFORMATION                                            *
;***************************************************************
	.sym	_int16, 0, 4, 13, 16
	.sym	_Uint16, 0, 14, 13, 16
	.sym	_Uint32, 0, 15, 13, 32
	.sym	_PINT, 0, 144, 13, 22
	.stag	_ADCTRL1_BITS, 16
	.member	_rsvd1, 0, 14, 18, 4
	.member	_SEQ_CASC, 4, 14, 18, 1
	.member	_SEQ_OVRD, 5, 14, 18, 1
	.member	_CONT_RUN, 6, 14, 18, 1
	.member	_CPS, 7, 14, 18, 1
	.member	_ACQ_PS, 8, 14, 18, 4
	.member	_SUSMOD, 12, 14, 18, 2
	.member	_RESET, 14, 14, 18, 1
	.member	_rsvd2, 15, 14, 18, 1
	.eos
	.utag	_ADCTRL1_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCTRL1_BITS
	.eos
	.stag	_ADCTRL2_BITS, 16
	.member	_EPWM_SOCB_SEQ2, 0, 14, 18, 1
	.member	_rsvd1, 1, 14, 18, 1
	.member	_INT_MOD_SEQ2, 2, 14, 18, 1
	.member	_INT_ENA_SEQ2, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 1
	.member	_SOC_SEQ2, 5, 14, 18, 1
	.member	_RST_SEQ2, 6, 14, 18, 1
	.member	_EXT_SOC_SEQ1, 7, 14, 18, 1
	.member	_EPWM_SOCA_SEQ1, 8, 14, 18, 1
	.member	_rsvd3, 9, 14, 18, 1
	.member	_INT_MOD_SEQ1, 10, 14, 18, 1
	.member	_INT_ENA_SEQ1, 11, 14, 18, 1
	.member	_rsvd4, 12, 14, 18, 1
	.member	_SOC_SEQ1, 13, 14, 18, 1
	.member	_RST_SEQ1, 14, 14, 18, 1
	.member	_EPWM_SOCB_SEQ, 15, 14, 18, 1
	.eos
	.utag	_ADCTRL2_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCTRL2_BITS
	.eos
	.stag	_ADCMAXCONV_BITS, 16
	.member	_MAX_CONV1, 0, 14, 18, 4
	.member	_MAX_CONV2, 4, 14, 18, 3
	.member	_rsvd1, 7, 14, 18, 9
	.eos
	.utag	_ADCMAXCONV_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCMAXCONV_BITS
	.eos
	.stag	_ADCCHSELSEQ1_BITS, 16
	.member	_CONV00, 0, 14, 18, 4
	.member	_CONV01, 4, 14, 18, 4
	.member	_CONV02, 8, 14, 18, 4
	.member	_CONV03, 12, 14, 18, 4
	.eos
	.utag	_ADCCHSELSEQ1_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCCHSELSEQ1_BITS
	.eos
	.stag	_ADCCHSELSEQ2_BITS, 16
	.member	_CONV04, 0, 14, 18, 4
	.member	_CONV05, 4, 14, 18, 4
	.member	_CONV06, 8, 14, 18, 4
	.member	_CONV07, 12, 14, 18, 4
	.eos
	.utag	_ADCCHSELSEQ2_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCCHSELSEQ2_BITS
	.eos
	.stag	_ADCCHSELSEQ3_BITS, 16
	.member	_CONV08, 0, 14, 18, 4
	.member	_CONV09, 4, 14, 18, 4
	.member	_CONV10, 8, 14, 18, 4
	.member	_CONV11, 12, 14, 18, 4
	.eos
	.utag	_ADCCHSELSEQ3_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCCHSELSEQ3_BITS
	.eos
	.stag	_ADCCHSELSEQ4_BITS, 16
	.member	_CONV12, 0, 14, 18, 4
	.member	_CONV13, 4, 14, 18, 4
	.member	_CONV14, 8, 14, 18, 4
	.member	_CONV15, 12, 14, 18, 4
	.eos
	.utag	_ADCCHSELSEQ4_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCCHSELSEQ4_BITS
	.eos
	.stag	_ADCASEQSR_BITS, 16
	.member	_SEQ1_STATE, 0, 14, 18, 4
	.member	_SEQ2_STATE, 4, 14, 18, 3
	.member	_rsvd1, 7, 14, 18, 1
	.member	_SEQ_CNTR, 8, 14, 18, 4
	.member	_rsvd2, 12, 14, 18, 4
	.eos
	.utag	_ADCASEQSR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCASEQSR_BITS
	.eos
	.stag	_ADCTRL3_BITS, 16
	.member	_SMODE_SEL, 0, 14, 18, 1
	.member	_ADCCLKPS, 1, 14, 18, 4
	.member	_ADCPWDN, 5, 14, 18, 1
	.member	_ADCBGRFDN, 6, 14, 18, 2
	.member	_rsvd1, 8, 14, 18, 8
	.eos
	.utag	_ADCTRL3_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCTRL3_BITS
	.eos
	.stag	_ADCST_BITS, 16
	.member	_INT_SEQ1, 0, 14, 18, 1
	.member	_INT_SEQ2, 1, 14, 18, 1
	.member	_SEQ1_BSY, 2, 14, 18, 1
	.member	_SEQ2_BSY, 3, 14, 18, 1
	.member	_INT_SEQ1_CLR, 4, 14, 18, 1
	.member	_INT_SEQ2_CLR, 5, 14, 18, 1
	.member	_EOS_BUF1, 6, 14, 18, 1
	.member	_EOS_BUF2, 7, 14, 18, 1
	.member	_rsvd1, 8, 14, 18, 8
	.eos
	.utag	_ADCST_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCST_BITS
	.eos
	.stag	_ADCREFSEL_BITS, 16
	.member	_rsvd1, 0, 14, 18, 14
	.member	_REF_SEL, 14, 14, 18, 2
	.eos
	.utag	_ADCREFSEL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCREFSEL_BITS
	.eos
	.stag	_ADCOFFTRIM_BITS, 16
	.member	_OFFSET_TRIM, 0, 4, 18, 9
	.member	_rsvd1, 9, 14, 18, 7
	.eos
	.utag	_ADCOFFTRIM_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ADCOFFTRIM_BITS
	.eos
	.stag	_ADC_REGS, 480
	.member	_ADCTRL1, 0, 9, 8, 16, _ADCTRL1_REG
	.member	_ADCTRL2, 16, 9, 8, 16, _ADCTRL2_REG
	.member	_ADCMAXCONV, 32, 9, 8, 16, _ADCMAXCONV_REG
	.member	_ADCCHSELSEQ1, 48, 9, 8, 16, _ADCCHSELSEQ1_REG
	.member	_ADCCHSELSEQ2, 64, 9, 8, 16, _ADCCHSELSEQ2_REG
	.member	_ADCCHSELSEQ3, 80, 9, 8, 16, _ADCCHSELSEQ3_REG
	.member	_ADCCHSELSEQ4, 96, 9, 8, 16, _ADCCHSELSEQ4_REG
	.member	_ADCASEQSR, 112, 9, 8, 16, _ADCASEQSR_REG
	.member	_ADCRESULT0, 128, 14, 8, 16
	.member	_ADCRESULT1, 144, 14, 8, 16
	.member	_ADCRESULT2, 160, 14, 8, 16
	.member	_ADCRESULT3, 176, 14, 8, 16
	.member	_ADCRESULT4, 192, 14, 8, 16
	.member	_ADCRESULT5, 208, 14, 8, 16
	.member	_ADCRESULT6, 224, 14, 8, 16
	.member	_ADCRESULT7, 240, 14, 8, 16
	.member	_ADCRESULT8, 256, 14, 8, 16
	.member	_ADCRESULT9, 272, 14, 8, 16
	.member	_ADCRESULT10, 288, 14, 8, 16
	.member	_ADCRESULT11, 304, 14, 8, 16
	.member	_ADCRESULT12, 320, 14, 8, 16
	.member	_ADCRESULT13, 336, 14, 8, 16
	.member	_ADCRESULT14, 352, 14, 8, 16
	.member	_ADCRESULT15, 368, 14, 8, 16
	.member	_ADCTRL3, 384, 9, 8, 16, _ADCTRL3_REG
	.member	_ADCST, 400, 9, 8, 16, _ADCST_REG
	.member	_rsvd1, 416, 14, 8, 16
	.member	_rsvd2, 432, 14, 8, 16
	.member	_ADCREFSEL, 448, 9, 8, 16, _ADCREFSEL_REG
	.member	_ADCOFFTRIM, 464, 9, 8, 16, _ADCOFFTRIM_REG
	.eos
	.stag	_ADC_RESULT_MIRROR_REGS, 256
	.member	_ADCRESULT0, 0, 14, 8, 16
	.member	_ADCRESULT1, 16, 14, 8, 16
	.member	_ADCRESULT2, 32, 14, 8, 16
	.member	_ADCRESULT3, 48, 14, 8, 16
	.member	_ADCRESULT4, 64, 14, 8, 16
	.member	_ADCRESULT5, 80, 14, 8, 16
	.member	_ADCRESULT6, 96, 14, 8, 16
	.member	_ADCRESULT7, 112, 14, 8, 16
	.member	_ADCRESULT8, 128, 14, 8, 16
	.member	_ADCRESULT9, 144, 14, 8, 16
	.member	_ADCRESULT10, 160, 14, 8, 16
	.member	_ADCRESULT11, 176, 14, 8, 16
	.member	_ADCRESULT12, 192, 14, 8, 16
	.member	_ADCRESULT13, 208, 14, 8, 16
	.member	_ADCRESULT14, 224, 14, 8, 16
	.member	_ADCRESULT15, 240, 14, 8, 16
	.eos
	.stag	_TIM_REG, 32
	.member	_LSW, 0, 14, 8, 16
	.member	_MSW, 16, 14, 8, 16
	.eos
	.utag	_TIM_GROUP, 32
	.member	_all, 0, 15, 11, 32
	.member	_half, 0, 8, 11, 32, _TIM_REG
	.eos
	.stag	_PRD_REG, 32
	.member	_LSW, 0, 14, 8, 16
	.member	_MSW, 16, 14, 8, 16
	.eos
	.utag	_PRD_GROUP, 32
	.member	_all, 0, 15, 11, 32
	.member	_half, 0, 8, 11, 32, _PRD_REG
	.eos
	.stag	_TCR_BITS, 16
	.member	_rsvd1, 0, 14, 18, 4
	.member	_TSS, 4, 14, 18, 1
	.member	_TRB, 5, 14, 18, 1
	.member	_rsvd2, 6, 14, 18, 4
	.member	_SOFT, 10, 14, 18, 1
	.member	_FREE, 11, 14, 18, 1
	.member	_rsvd3, 12, 14, 18, 2
	.member	_TIE, 14, 14, 18, 1
	.member	_TIF, 15, 14, 18, 1
	.eos
	.utag	_TCR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TCR_BITS
	.eos
	.stag	_TPR_BITS, 16
	.member	_TDDR, 0, 14, 18, 8
	.member	_PSC, 8, 14, 18, 8
	.eos
	.utag	_TPR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TPR_BITS
	.eos
	.stag	_TPRH_BITS, 16
	.member	_TDDRH, 0, 14, 18, 8
	.member	_PSCH, 8, 14, 18, 8
	.eos
	.utag	_TPRH_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TPRH_BITS
	.eos
	.stag	_CPUTIMER_REGS, 128
	.member	_TIM, 0, 9, 8, 32, _TIM_GROUP
	.member	_PRD, 32, 9, 8, 32, _PRD_GROUP
	.member	_TCR, 64, 9, 8, 16, _TCR_REG
	.member	_rsvd1, 80, 14, 8, 16
	.member	_TPR, 96, 9, 8, 16, _TPR_REG
	.member	_TPRH, 112, 9, 8, 16, _TPRH_REG
	.eos
	.stag	_CSM_PWL, 128
	.member	_PSWD0, 0, 14, 8, 16
	.member	_PSWD1, 16, 14, 8, 16
	.member	_PSWD2, 32, 14, 8, 16
	.member	_PSWD3, 48, 14, 8, 16
	.member	_PSWD4, 64, 14, 8, 16
	.member	_PSWD5, 80, 14, 8, 16
	.member	_PSWD6, 96, 14, 8, 16
	.member	_PSWD7, 112, 14, 8, 16
	.eos
	.stag	_CSMSCR_BITS, 16
	.member	_SECURE, 0, 14, 18, 1
	.member	_rsvd1, 1, 14, 18, 14
	.member	_FORCESEC, 15, 14, 18, 1
	.eos
	.utag	_CSMSCR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _CSMSCR_BITS
	.eos
	.stag	_CSM_REGS, 256
	.member	_KEY0, 0, 14, 8, 16
	.member	_KEY1, 16, 14, 8, 16
	.member	_KEY2, 32, 14, 8, 16
	.member	_KEY3, 48, 14, 8, 16
	.member	_KEY4, 64, 14, 8, 16
	.member	_KEY5, 80, 14, 8, 16
	.member	_KEY6, 96, 14, 8, 16
	.member	_KEY7, 112, 14, 8, 16
	.member	_rsvd1, 128, 14, 8, 16
	.member	_rsvd2, 144, 14, 8, 16
	.member	_rsvd3, 160, 14, 8, 16
	.member	_rsvd4, 176, 14, 8, 16
	.member	_rsvd5, 192, 14, 8, 16
	.member	_rsvd6, 208, 14, 8, 16
	.member	_rsvd7, 224, 14, 8, 16
	.member	_CSMSCR, 240, 9, 8, 16, _CSMSCR_REG
	.eos
	.stag	_DEVICECNF_BITS, 32
	.member	_rsvd1, 0, 14, 18, 3
	.member	_VMAPS, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 1
	.member	_XRSn, 5, 14, 18, 1
	.member	_rsvd3, 6, 14, 18, 10
	.member	_rsvd4, 16, 14, 18, 3
	.member	_ENPROT, 19, 14, 18, 1
	.member	_MONPRIV, 20, 14, 18, 1
	.member	_rsvd5, 21, 14, 18, 1
	.member	_EMU0SEL, 22, 14, 18, 2
	.member	_EMU1SEL, 24, 14, 18, 2
	.member	_rsvd6, 26, 14, 18, 6
	.eos
	.utag	_DEVICECNF_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _DEVICECNF_BITS
	.eos
	.stag	_DEV_EMU_REGS, 3328
	.member	_DEVICECNF, 0, 9, 8, 32, _DEVICECNF_REG
	.member	_PARTID, 32, 14, 8, 16
	.member	_REVID, 48, 14, 8, 16
	.member	_PROTSTART, 64, 14, 8, 16
	.member	_PROTRANGE, 80, 14, 8, 16
	.member	_rsvd2, 96, 62, 8, 3232, , 202
	.eos
	.stag	_CANME_BITS, 32
	.member	_ME0, 0, 14, 18, 1
	.member	_ME1, 1, 14, 18, 1
	.member	_ME2, 2, 14, 18, 1
	.member	_ME3, 3, 14, 18, 1
	.member	_ME4, 4, 14, 18, 1
	.member	_ME5, 5, 14, 18, 1
	.member	_ME6, 6, 14, 18, 1
	.member	_ME7, 7, 14, 18, 1
	.member	_ME8, 8, 14, 18, 1
	.member	_ME9, 9, 14, 18, 1
	.member	_ME10, 10, 14, 18, 1
	.member	_ME11, 11, 14, 18, 1
	.member	_ME12, 12, 14, 18, 1
	.member	_ME13, 13, 14, 18, 1
	.member	_ME14, 14, 14, 18, 1
	.member	_ME15, 15, 14, 18, 1
	.member	_ME16, 16, 14, 18, 1
	.member	_ME17, 17, 14, 18, 1
	.member	_ME18, 18, 14, 18, 1
	.member	_ME19, 19, 14, 18, 1
	.member	_ME20, 20, 14, 18, 1
	.member	_ME21, 21, 14, 18, 1
	.member	_ME22, 22, 14, 18, 1
	.member	_ME23, 23, 14, 18, 1
	.member	_ME24, 24, 14, 18, 1
	.member	_ME25, 25, 14, 18, 1
	.member	_ME26, 26, 14, 18, 1
	.member	_ME27, 27, 14, 18, 1
	.member	_ME28, 28, 14, 18, 1
	.member	_ME29, 29, 14, 18, 1
	.member	_ME30, 30, 14, 18, 1
	.member	_ME31, 31, 14, 18, 1
	.eos
	.utag	_CANME_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANME_BITS
	.eos
	.stag	_CANMD_BITS, 32
	.member	_MD0, 0, 14, 18, 1
	.member	_MD1, 1, 14, 18, 1
	.member	_MD2, 2, 14, 18, 1
	.member	_MD3, 3, 14, 18, 1
	.member	_MD4, 4, 14, 18, 1
	.member	_MD5, 5, 14, 18, 1
	.member	_MD6, 6, 14, 18, 1
	.member	_MD7, 7, 14, 18, 1
	.member	_MD8, 8, 14, 18, 1
	.member	_MD9, 9, 14, 18, 1
	.member	_MD10, 10, 14, 18, 1
	.member	_MD11, 11, 14, 18, 1
	.member	_MD12, 12, 14, 18, 1
	.member	_MD13, 13, 14, 18, 1
	.member	_MD14, 14, 14, 18, 1
	.member	_MD15, 15, 14, 18, 1
	.member	_MD16, 16, 14, 18, 1
	.member	_MD17, 17, 14, 18, 1
	.member	_MD18, 18, 14, 18, 1
	.member	_MD19, 19, 14, 18, 1
	.member	_MD20, 20, 14, 18, 1
	.member	_MD21, 21, 14, 18, 1
	.member	_MD22, 22, 14, 18, 1
	.member	_MD23, 23, 14, 18, 1
	.member	_MD24, 24, 14, 18, 1
	.member	_MD25, 25, 14, 18, 1
	.member	_MD26, 26, 14, 18, 1
	.member	_MD27, 27, 14, 18, 1
	.member	_MD28, 28, 14, 18, 1
	.member	_MD29, 29, 14, 18, 1
	.member	_MD30, 30, 14, 18, 1
	.member	_MD31, 31, 14, 18, 1
	.eos
	.utag	_CANMD_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANMD_BITS
	.eos
	.stag	_CANTRS_BITS, 32
	.member	_TRS0, 0, 14, 18, 1
	.member	_TRS1, 1, 14, 18, 1
	.member	_TRS2, 2, 14, 18, 1
	.member	_TRS3, 3, 14, 18, 1
	.member	_TRS4, 4, 14, 18, 1
	.member	_TRS5, 5, 14, 18, 1
	.member	_TRS6, 6, 14, 18, 1
	.member	_TRS7, 7, 14, 18, 1
	.member	_TRS8, 8, 14, 18, 1
	.member	_TRS9, 9, 14, 18, 1
	.member	_TRS10, 10, 14, 18, 1
	.member	_TRS11, 11, 14, 18, 1
	.member	_TRS12, 12, 14, 18, 1
	.member	_TRS13, 13, 14, 18, 1
	.member	_TRS14, 14, 14, 18, 1
	.member	_TRS15, 15, 14, 18, 1
	.member	_TRS16, 16, 14, 18, 1
	.member	_TRS17, 17, 14, 18, 1
	.member	_TRS18, 18, 14, 18, 1
	.member	_TRS19, 19, 14, 18, 1
	.member	_TRS20, 20, 14, 18, 1
	.member	_TRS21, 21, 14, 18, 1
	.member	_TRS22, 22, 14, 18, 1
	.member	_TRS23, 23, 14, 18, 1
	.member	_TRS24, 24, 14, 18, 1
	.member	_TRS25, 25, 14, 18, 1
	.member	_TRS26, 26, 14, 18, 1
	.member	_TRS27, 27, 14, 18, 1
	.member	_TRS28, 28, 14, 18, 1
	.member	_TRS29, 29, 14, 18, 1
	.member	_TRS30, 30, 14, 18, 1
	.member	_TRS31, 31, 14, 18, 1
	.eos
	.utag	_CANTRS_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANTRS_BITS
	.eos
	.stag	_CANTRR_BITS, 32
	.member	_TRR0, 0, 14, 18, 1
	.member	_TRR1, 1, 14, 18, 1
	.member	_TRR2, 2, 14, 18, 1
	.member	_TRR3, 3, 14, 18, 1
	.member	_TRR4, 4, 14, 18, 1
	.member	_TRR5, 5, 14, 18, 1
	.member	_TRR6, 6, 14, 18, 1
	.member	_TRR7, 7, 14, 18, 1
	.member	_TRR8, 8, 14, 18, 1
	.member	_TRR9, 9, 14, 18, 1
	.member	_TRR10, 10, 14, 18, 1
	.member	_TRR11, 11, 14, 18, 1
	.member	_TRR12, 12, 14, 18, 1
	.member	_TRR13, 13, 14, 18, 1
	.member	_TRR14, 14, 14, 18, 1
	.member	_TRR15, 15, 14, 18, 1
	.member	_TRR16, 16, 14, 18, 1
	.member	_TRR17, 17, 14, 18, 1
	.member	_TRR18, 18, 14, 18, 1
	.member	_TRR19, 19, 14, 18, 1
	.member	_TRR20, 20, 14, 18, 1
	.member	_TRR21, 21, 14, 18, 1
	.member	_TRR22, 22, 14, 18, 1
	.member	_TRR23, 23, 14, 18, 1
	.member	_TRR24, 24, 14, 18, 1
	.member	_TRR25, 25, 14, 18, 1
	.member	_TRR26, 26, 14, 18, 1
	.member	_TRR27, 27, 14, 18, 1
	.member	_TRR28, 28, 14, 18, 1
	.member	_TRR29, 29, 14, 18, 1
	.member	_TRR30, 30, 14, 18, 1
	.member	_TRR31, 31, 14, 18, 1
	.eos
	.utag	_CANTRR_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANTRR_BITS
	.eos
	.stag	_CANTA_BITS, 32
	.member	_TA0, 0, 14, 18, 1
	.member	_TA1, 1, 14, 18, 1
	.member	_TA2, 2, 14, 18, 1
	.member	_TA3, 3, 14, 18, 1
	.member	_TA4, 4, 14, 18, 1
	.member	_TA5, 5, 14, 18, 1
	.member	_TA6, 6, 14, 18, 1
	.member	_TA7, 7, 14, 18, 1
	.member	_TA8, 8, 14, 18, 1
	.member	_TA9, 9, 14, 18, 1
	.member	_TA10, 10, 14, 18, 1
	.member	_TA11, 11, 14, 18, 1
	.member	_TA12, 12, 14, 18, 1
	.member	_TA13, 13, 14, 18, 1
	.member	_TA14, 14, 14, 18, 1
	.member	_TA15, 15, 14, 18, 1
	.member	_TA16, 16, 14, 18, 1
	.member	_TA17, 17, 14, 18, 1
	.member	_TA18, 18, 14, 18, 1
	.member	_TA19, 19, 14, 18, 1
	.member	_TA20, 20, 14, 18, 1
	.member	_TA21, 21, 14, 18, 1
	.member	_TA22, 22, 14, 18, 1
	.member	_TA23, 23, 14, 18, 1
	.member	_TA24, 24, 14, 18, 1
	.member	_TA25, 25, 14, 18, 1
	.member	_TA26, 26, 14, 18, 1
	.member	_TA27, 27, 14, 18, 1
	.member	_TA28, 28, 14, 18, 1
	.member	_TA29, 29, 14, 18, 1
	.member	_TA30, 30, 14, 18, 1
	.member	_TA31, 31, 14, 18, 1
	.eos
	.utag	_CANTA_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANTA_BITS
	.eos
	.stag	_CANAA_BITS, 32
	.member	_AA0, 0, 14, 18, 1
	.member	_AA1, 1, 14, 18, 1
	.member	_AA2, 2, 14, 18, 1
	.member	_AA3, 3, 14, 18, 1
	.member	_AA4, 4, 14, 18, 1
	.member	_AA5, 5, 14, 18, 1
	.member	_AA6, 6, 14, 18, 1
	.member	_AA7, 7, 14, 18, 1
	.member	_AA8, 8, 14, 18, 1
	.member	_AA9, 9, 14, 18, 1
	.member	_AA10, 10, 14, 18, 1
	.member	_AA11, 11, 14, 18, 1
	.member	_AA12, 12, 14, 18, 1
	.member	_AA13, 13, 14, 18, 1
	.member	_AA14, 14, 14, 18, 1
	.member	_AA15, 15, 14, 18, 1
	.member	_AA16, 16, 14, 18, 1
	.member	_AA17, 17, 14, 18, 1
	.member	_AA18, 18, 14, 18, 1
	.member	_AA19, 19, 14, 18, 1
	.member	_AA20, 20, 14, 18, 1
	.member	_AA21, 21, 14, 18, 1
	.member	_AA22, 22, 14, 18, 1
	.member	_AA23, 23, 14, 18, 1
	.member	_AA24, 24, 14, 18, 1
	.member	_AA25, 25, 14, 18, 1
	.member	_AA26, 26, 14, 18, 1
	.member	_AA27, 27, 14, 18, 1
	.member	_AA28, 28, 14, 18, 1
	.member	_AA29, 29, 14, 18, 1
	.member	_AA30, 30, 14, 18, 1
	.member	_AA31, 31, 14, 18, 1
	.eos
	.utag	_CANAA_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANAA_BITS
	.eos
	.stag	_CANRMP_BITS, 32
	.member	_RMP0, 0, 14, 18, 1
	.member	_RMP1, 1, 14, 18, 1
	.member	_RMP2, 2, 14, 18, 1
	.member	_RMP3, 3, 14, 18, 1
	.member	_RMP4, 4, 14, 18, 1
	.member	_RMP5, 5, 14, 18, 1
	.member	_RMP6, 6, 14, 18, 1
	.member	_RMP7, 7, 14, 18, 1
	.member	_RMP8, 8, 14, 18, 1
	.member	_RMP9, 9, 14, 18, 1
	.member	_RMP10, 10, 14, 18, 1
	.member	_RMP11, 11, 14, 18, 1
	.member	_RMP12, 12, 14, 18, 1
	.member	_RMP13, 13, 14, 18, 1
	.member	_RMP14, 14, 14, 18, 1
	.member	_RMP15, 15, 14, 18, 1
	.member	_RMP16, 16, 14, 18, 1
	.member	_RMP17, 17, 14, 18, 1
	.member	_RMP18, 18, 14, 18, 1
	.member	_RMP19, 19, 14, 18, 1
	.member	_RMP20, 20, 14, 18, 1
	.member	_RMP21, 21, 14, 18, 1
	.member	_RMP22, 22, 14, 18, 1
	.member	_RMP23, 23, 14, 18, 1
	.member	_RMP24, 24, 14, 18, 1
	.member	_RMP25, 25, 14, 18, 1
	.member	_RMP26, 26, 14, 18, 1
	.member	_RMP27, 27, 14, 18, 1
	.member	_RMP28, 28, 14, 18, 1
	.member	_RMP29, 29, 14, 18, 1
	.member	_RMP30, 30, 14, 18, 1
	.member	_RMP31, 31, 14, 18, 1
	.eos
	.utag	_CANRMP_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANRMP_BITS
	.eos
	.stag	_CANRML_BITS, 32
	.member	_RML0, 0, 14, 18, 1
	.member	_RML1, 1, 14, 18, 1
	.member	_RML2, 2, 14, 18, 1
	.member	_RML3, 3, 14, 18, 1
	.member	_RML4, 4, 14, 18, 1
	.member	_RML5, 5, 14, 18, 1
	.member	_RML6, 6, 14, 18, 1
	.member	_RML7, 7, 14, 18, 1
	.member	_RML8, 8, 14, 18, 1
	.member	_RML9, 9, 14, 18, 1
	.member	_RML10, 10, 14, 18, 1
	.member	_RML11, 11, 14, 18, 1
	.member	_RML12, 12, 14, 18, 1
	.member	_RML13, 13, 14, 18, 1
	.member	_RML14, 14, 14, 18, 1
	.member	_RML15, 15, 14, 18, 1
	.member	_RML16, 16, 14, 18, 1
	.member	_RML17, 17, 14, 18, 1
	.member	_RML18, 18, 14, 18, 1
	.member	_RML19, 19, 14, 18, 1
	.member	_RML20, 20, 14, 18, 1
	.member	_RML21, 21, 14, 18, 1
	.member	_RML22, 22, 14, 18, 1
	.member	_RML23, 23, 14, 18, 1
	.member	_RML24, 24, 14, 18, 1
	.member	_RML25, 25, 14, 18, 1
	.member	_RML26, 26, 14, 18, 1
	.member	_RML27, 27, 14, 18, 1
	.member	_RML28, 28, 14, 18, 1
	.member	_RML29, 29, 14, 18, 1
	.member	_RML30, 30, 14, 18, 1
	.member	_RML31, 31, 14, 18, 1
	.eos
	.utag	_CANRML_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANRML_BITS
	.eos
	.stag	_CANRFP_BITS, 32
	.member	_RFP0, 0, 14, 18, 1
	.member	_RFP1, 1, 14, 18, 1
	.member	_RFP2, 2, 14, 18, 1
	.member	_RFP3, 3, 14, 18, 1
	.member	_RFP4, 4, 14, 18, 1
	.member	_RFP5, 5, 14, 18, 1
	.member	_RFP6, 6, 14, 18, 1
	.member	_RFP7, 7, 14, 18, 1
	.member	_RFP8, 8, 14, 18, 1
	.member	_RFP9, 9, 14, 18, 1
	.member	_RFP10, 10, 14, 18, 1
	.member	_RFP11, 11, 14, 18, 1
	.member	_RFP12, 12, 14, 18, 1
	.member	_RFP13, 13, 14, 18, 1
	.member	_RFP14, 14, 14, 18, 1
	.member	_RFP15, 15, 14, 18, 1
	.member	_RFP16, 16, 14, 18, 1
	.member	_RFP17, 17, 14, 18, 1
	.member	_RFP18, 18, 14, 18, 1
	.member	_RFP19, 19, 14, 18, 1
	.member	_RFP20, 20, 14, 18, 1
	.member	_RFP21, 21, 14, 18, 1
	.member	_RFP22, 22, 14, 18, 1
	.member	_RFP23, 23, 14, 18, 1
	.member	_RFP24, 24, 14, 18, 1
	.member	_RFP25, 25, 14, 18, 1
	.member	_RFP26, 26, 14, 18, 1
	.member	_RFP27, 27, 14, 18, 1
	.member	_RFP28, 28, 14, 18, 1
	.member	_RFP29, 29, 14, 18, 1
	.member	_RFP30, 30, 14, 18, 1
	.member	_RFP31, 31, 14, 18, 1
	.eos
	.utag	_CANRFP_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANRFP_BITS
	.eos
	.stag	_CANGAM_BITS, 32
	.member	_GAM150, 0, 14, 18, 16
	.member	_GAM2816, 16, 14, 18, 13
	.member	_rsvd, 29, 14, 18, 2
	.member	_AMI, 31, 14, 18, 1
	.eos
	.utag	_CANGAM_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANGAM_BITS
	.eos
	.stag	_CANMC_BITS, 32
	.member	_MBNR, 0, 14, 18, 5
	.member	_SRES, 5, 14, 18, 1
	.member	_STM, 6, 14, 18, 1
	.member	_ABO, 7, 14, 18, 1
	.member	_CDR, 8, 14, 18, 1
	.member	_WUBA, 9, 14, 18, 1
	.member	_DBO, 10, 14, 18, 1
	.member	_PDR, 11, 14, 18, 1
	.member	_CCR, 12, 14, 18, 1
	.member	_SCB, 13, 14, 18, 1
	.member	_TCC, 14, 14, 18, 1
	.member	_MBCC, 15, 14, 18, 1
	.member	_SUSP, 16, 14, 18, 1
	.member	_rsvd, 17, 14, 18, 15
	.eos
	.utag	_CANMC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANMC_BITS
	.eos
	.stag	_CANBTC_BITS, 32
	.member	_TSEG2REG, 0, 14, 18, 3
	.member	_TSEG1REG, 3, 14, 18, 4
	.member	_SAM, 7, 14, 18, 1
	.member	_SJWREG, 8, 14, 18, 2
	.member	_rsvd1, 10, 14, 18, 6
	.member	_BRPREG, 16, 14, 18, 8
	.member	_rsvd2, 24, 14, 18, 8
	.eos
	.utag	_CANBTC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANBTC_BITS
	.eos
	.stag	_CANES_BITS, 32
	.member	_TM, 0, 14, 18, 1
	.member	_RM, 1, 14, 18, 1
	.member	_rsvd1, 2, 14, 18, 1
	.member	_PDA, 3, 14, 18, 1
	.member	_CCE, 4, 14, 18, 1
	.member	_SMA, 5, 14, 18, 1
	.member	_rsvd2, 6, 14, 18, 10
	.member	_EW, 16, 14, 18, 1
	.member	_EP, 17, 14, 18, 1
	.member	_BO, 18, 14, 18, 1
	.member	_ACKE, 19, 14, 18, 1
	.member	_SE, 20, 14, 18, 1
	.member	_CRCE, 21, 14, 18, 1
	.member	_SA1, 22, 14, 18, 1
	.member	_BE, 23, 14, 18, 1
	.member	_FE, 24, 14, 18, 1
	.member	_rsvd3, 25, 14, 18, 7
	.eos
	.utag	_CANES_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANES_BITS
	.eos
	.stag	_CANTEC_BITS, 32
	.member	_TEC, 0, 14, 18, 8
	.member	_rsvd1, 8, 14, 18, 8
	.member	_rsvd2, 16, 14, 18, 16
	.eos
	.utag	_CANTEC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANTEC_BITS
	.eos
	.stag	_CANREC_BITS, 32
	.member	_REC, 0, 14, 18, 8
	.member	_rsvd1, 8, 14, 18, 8
	.member	_rsvd2, 16, 14, 18, 16
	.eos
	.utag	_CANREC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANREC_BITS
	.eos
	.stag	_CANGIF0_BITS, 32
	.member	_MIV0, 0, 14, 18, 5
	.member	_rsvd1, 5, 14, 18, 3
	.member	_WLIF0, 8, 14, 18, 1
	.member	_EPIF0, 9, 14, 18, 1
	.member	_BOIF0, 10, 14, 18, 1
	.member	_RMLIF0, 11, 14, 18, 1
	.member	_WUIF0, 12, 14, 18, 1
	.member	_WDIF0, 13, 14, 18, 1
	.member	_AAIF0, 14, 14, 18, 1
	.member	_GMIF0, 15, 14, 18, 1
	.member	_TCOF0, 16, 14, 18, 1
	.member	_MTOF0, 17, 14, 18, 1
	.member	_rsvd2, 18, 14, 18, 14
	.eos
	.utag	_CANGIF0_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANGIF0_BITS
	.eos
	.stag	_CANGIM_BITS, 32
	.member	_I0EN, 0, 14, 18, 1
	.member	_I1EN, 1, 14, 18, 1
	.member	_GIL, 2, 14, 18, 1
	.member	_rsvd1, 3, 14, 18, 5
	.member	_WLIM, 8, 14, 18, 1
	.member	_EPIM, 9, 14, 18, 1
	.member	_BOIM, 10, 14, 18, 1
	.member	_RMLIM, 11, 14, 18, 1
	.member	_WUIM, 12, 14, 18, 1
	.member	_WDIM, 13, 14, 18, 1
	.member	_AAIM, 14, 14, 18, 1
	.member	_rsvd2, 15, 14, 18, 1
	.member	_TCOM, 16, 14, 18, 1
	.member	_MTOM, 17, 14, 18, 1
	.member	_rsvd3, 18, 14, 18, 14
	.eos
	.utag	_CANGIM_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANGIM_BITS
	.eos
	.stag	_CANGIF1_BITS, 32
	.member	_MIV1, 0, 14, 18, 5
	.member	_rsvd1, 5, 14, 18, 3
	.member	_WLIF1, 8, 14, 18, 1
	.member	_EPIF1, 9, 14, 18, 1
	.member	_BOIF1, 10, 14, 18, 1
	.member	_RMLIF1, 11, 14, 18, 1
	.member	_WUIF1, 12, 14, 18, 1
	.member	_WDIF1, 13, 14, 18, 1
	.member	_AAIF1, 14, 14, 18, 1
	.member	_GMIF1, 15, 14, 18, 1
	.member	_TCOF1, 16, 14, 18, 1
	.member	_MTOF1, 17, 14, 18, 1
	.member	_rsvd2, 18, 14, 18, 14
	.eos
	.utag	_CANGIF1_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANGIF1_BITS
	.eos
	.stag	_CANMIM_BITS, 32
	.member	_MIM0, 0, 14, 18, 1
	.member	_MIM1, 1, 14, 18, 1
	.member	_MIM2, 2, 14, 18, 1
	.member	_MIM3, 3, 14, 18, 1
	.member	_MIM4, 4, 14, 18, 1
	.member	_MIM5, 5, 14, 18, 1
	.member	_MIM6, 6, 14, 18, 1
	.member	_MIM7, 7, 14, 18, 1
	.member	_MIM8, 8, 14, 18, 1
	.member	_MIM9, 9, 14, 18, 1
	.member	_MIM10, 10, 14, 18, 1
	.member	_MIM11, 11, 14, 18, 1
	.member	_MIM12, 12, 14, 18, 1
	.member	_MIM13, 13, 14, 18, 1
	.member	_MIM14, 14, 14, 18, 1
	.member	_MIM15, 15, 14, 18, 1
	.member	_MIM16, 16, 14, 18, 1
	.member	_MIM17, 17, 14, 18, 1
	.member	_MIM18, 18, 14, 18, 1
	.member	_MIM19, 19, 14, 18, 1
	.member	_MIM20, 20, 14, 18, 1
	.member	_MIM21, 21, 14, 18, 1
	.member	_MIM22, 22, 14, 18, 1
	.member	_MIM23, 23, 14, 18, 1
	.member	_MIM24, 24, 14, 18, 1
	.member	_MIM25, 25, 14, 18, 1
	.member	_MIM26, 26, 14, 18, 1
	.member	_MIM27, 27, 14, 18, 1
	.member	_MIM28, 28, 14, 18, 1
	.member	_MIM29, 29, 14, 18, 1
	.member	_MIM30, 30, 14, 18, 1
	.member	_MIM31, 31, 14, 18, 1
	.eos
	.utag	_CANMIM_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANMIM_BITS
	.eos
	.stag	_CANMIL_BITS, 32
	.member	_MIL0, 0, 14, 18, 1
	.member	_MIL1, 1, 14, 18, 1
	.member	_MIL2, 2, 14, 18, 1
	.member	_MIL3, 3, 14, 18, 1
	.member	_MIL4, 4, 14, 18, 1
	.member	_MIL5, 5, 14, 18, 1
	.member	_MIL6, 6, 14, 18, 1
	.member	_MIL7, 7, 14, 18, 1
	.member	_MIL8, 8, 14, 18, 1
	.member	_MIL9, 9, 14, 18, 1
	.member	_MIL10, 10, 14, 18, 1
	.member	_MIL11, 11, 14, 18, 1
	.member	_MIL12, 12, 14, 18, 1
	.member	_MIL13, 13, 14, 18, 1
	.member	_MIL14, 14, 14, 18, 1
	.member	_MIL15, 15, 14, 18, 1
	.member	_MIL16, 16, 14, 18, 1
	.member	_MIL17, 17, 14, 18, 1
	.member	_MIL18, 18, 14, 18, 1
	.member	_MIL19, 19, 14, 18, 1
	.member	_MIL20, 20, 14, 18, 1
	.member	_MIL21, 21, 14, 18, 1
	.member	_MIL22, 22, 14, 18, 1
	.member	_MIL23, 23, 14, 18, 1
	.member	_MIL24, 24, 14, 18, 1
	.member	_MIL25, 25, 14, 18, 1
	.member	_MIL26, 26, 14, 18, 1
	.member	_MIL27, 27, 14, 18, 1
	.member	_MIL28, 28, 14, 18, 1
	.member	_MIL29, 29, 14, 18, 1
	.member	_MIL30, 30, 14, 18, 1
	.member	_MIL31, 31, 14, 18, 1
	.eos
	.utag	_CANMIL_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANMIL_BITS
	.eos
	.stag	_CANOPC_BITS, 32
	.member	_OPC0, 0, 14, 18, 1
	.member	_OPC1, 1, 14, 18, 1
	.member	_OPC2, 2, 14, 18, 1
	.member	_OPC3, 3, 14, 18, 1
	.member	_OPC4, 4, 14, 18, 1
	.member	_OPC5, 5, 14, 18, 1
	.member	_OPC6, 6, 14, 18, 1
	.member	_OPC7, 7, 14, 18, 1
	.member	_OPC8, 8, 14, 18, 1
	.member	_OPC9, 9, 14, 18, 1
	.member	_OPC10, 10, 14, 18, 1
	.member	_OPC11, 11, 14, 18, 1
	.member	_OPC12, 12, 14, 18, 1
	.member	_OPC13, 13, 14, 18, 1
	.member	_OPC14, 14, 14, 18, 1
	.member	_OPC15, 15, 14, 18, 1
	.member	_OPC16, 16, 14, 18, 1
	.member	_OPC17, 17, 14, 18, 1
	.member	_OPC18, 18, 14, 18, 1
	.member	_OPC19, 19, 14, 18, 1
	.member	_OPC20, 20, 14, 18, 1
	.member	_OPC21, 21, 14, 18, 1
	.member	_OPC22, 22, 14, 18, 1
	.member	_OPC23, 23, 14, 18, 1
	.member	_OPC24, 24, 14, 18, 1
	.member	_OPC25, 25, 14, 18, 1
	.member	_OPC26, 26, 14, 18, 1
	.member	_OPC27, 27, 14, 18, 1
	.member	_OPC28, 28, 14, 18, 1
	.member	_OPC29, 29, 14, 18, 1
	.member	_OPC30, 30, 14, 18, 1
	.member	_OPC31, 31, 14, 18, 1
	.eos
	.utag	_CANOPC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANOPC_BITS
	.eos
	.stag	_CANTIOC_BITS, 32
	.member	_rsvd1, 0, 14, 18, 3
	.member	_TXFUNC, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 12
	.member	_rsvd3, 16, 14, 18, 16
	.eos
	.utag	_CANTIOC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANTIOC_BITS
	.eos
	.stag	_CANRIOC_BITS, 32
	.member	_rsvd1, 0, 14, 18, 3
	.member	_RXFUNC, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 12
	.member	_rsvd3, 16, 14, 18, 16
	.eos
	.utag	_CANRIOC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANRIOC_BITS
	.eos
	.stag	_CANTOC_BITS, 32
	.member	_TOC0, 0, 14, 18, 1
	.member	_TOC1, 1, 14, 18, 1
	.member	_TOC2, 2, 14, 18, 1
	.member	_TOC3, 3, 14, 18, 1
	.member	_TOC4, 4, 14, 18, 1
	.member	_TOC5, 5, 14, 18, 1
	.member	_TOC6, 6, 14, 18, 1
	.member	_TOC7, 7, 14, 18, 1
	.member	_TOC8, 8, 14, 18, 1
	.member	_TOC9, 9, 14, 18, 1
	.member	_TOC10, 10, 14, 18, 1
	.member	_TOC11, 11, 14, 18, 1
	.member	_TOC12, 12, 14, 18, 1
	.member	_TOC13, 13, 14, 18, 1
	.member	_TOC14, 14, 14, 18, 1
	.member	_TOC15, 15, 14, 18, 1
	.member	_TOC16, 16, 14, 18, 1
	.member	_TOC17, 17, 14, 18, 1
	.member	_TOC18, 18, 14, 18, 1
	.member	_TOC19, 19, 14, 18, 1
	.member	_TOC20, 20, 14, 18, 1
	.member	_TOC21, 21, 14, 18, 1
	.member	_TOC22, 22, 14, 18, 1
	.member	_TOC23, 23, 14, 18, 1
	.member	_TOC24, 24, 14, 18, 1
	.member	_TOC25, 25, 14, 18, 1
	.member	_TOC26, 26, 14, 18, 1
	.member	_TOC27, 27, 14, 18, 1
	.member	_TOC28, 28, 14, 18, 1
	.member	_TOC29, 29, 14, 18, 1
	.member	_TOC30, 30, 14, 18, 1
	.member	_TOC31, 31, 14, 18, 1
	.eos
	.utag	_CANTOC_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANTOC_BITS
	.eos
	.stag	_CANTOS_BITS, 32
	.member	_TOS0, 0, 14, 18, 1
	.member	_TOS1, 1, 14, 18, 1
	.member	_TOS2, 2, 14, 18, 1
	.member	_TOS3, 3, 14, 18, 1
	.member	_TOS4, 4, 14, 18, 1
	.member	_TOS5, 5, 14, 18, 1
	.member	_TOS6, 6, 14, 18, 1
	.member	_TOS7, 7, 14, 18, 1
	.member	_TOS8, 8, 14, 18, 1
	.member	_TOS9, 9, 14, 18, 1
	.member	_TOS10, 10, 14, 18, 1
	.member	_TOS11, 11, 14, 18, 1
	.member	_TOS12, 12, 14, 18, 1
	.member	_TOS13, 13, 14, 18, 1
	.member	_TOS14, 14, 14, 18, 1
	.member	_TOS15, 15, 14, 18, 1
	.member	_TOS16, 16, 14, 18, 1
	.member	_TOS17, 17, 14, 18, 1
	.member	_TOS18, 18, 14, 18, 1
	.member	_TOS19, 19, 14, 18, 1
	.member	_TOS20, 20, 14, 18, 1
	.member	_TOS21, 21, 14, 18, 1
	.member	_TOS22, 22, 14, 18, 1
	.member	_TOS23, 23, 14, 18, 1
	.member	_TOS24, 24, 14, 18, 1
	.member	_TOS25, 25, 14, 18, 1
	.member	_TOS26, 26, 14, 18, 1
	.member	_TOS27, 27, 14, 18, 1
	.member	_TOS28, 28, 14, 18, 1
	.member	_TOS29, 29, 14, 18, 1
	.member	_TOS30, 30, 14, 18, 1
	.member	_TOS31, 31, 14, 18, 1
	.eos
	.utag	_CANTOS_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANTOS_BITS
	.eos
	.stag	_ECAN_REGS, 832
	.member	_CANME, 0, 9, 8, 32, _CANME_REG
	.member	_CANMD, 32, 9, 8, 32, _CANMD_REG
	.member	_CANTRS, 64, 9, 8, 32, _CANTRS_REG
	.member	_CANTRR, 96, 9, 8, 32, _CANTRR_REG
	.member	_CANTA, 128, 9, 8, 32, _CANTA_REG
	.member	_CANAA, 160, 9, 8, 32, _CANAA_REG
	.member	_CANRMP, 192, 9, 8, 32, _CANRMP_REG
	.member	_CANRML, 224, 9, 8, 32, _CANRML_REG
	.member	_CANRFP, 256, 9, 8, 32, _CANRFP_REG
	.member	_CANGAM, 288, 9, 8, 32, _CANGAM_REG
	.member	_CANMC, 320, 9, 8, 32, _CANMC_REG
	.member	_CANBTC, 352, 9, 8, 32, _CANBTC_REG
	.member	_CANES, 384, 9, 8, 32, _CANES_REG
	.member	_CANTEC, 416, 9, 8, 32, _CANTEC_REG
	.member	_CANREC, 448, 9, 8, 32, _CANREC_REG
	.member	_CANGIF0, 480, 9, 8, 32, _CANGIF0_REG
	.member	_CANGIM, 512, 9, 8, 32, _CANGIM_REG
	.member	_CANGIF1, 544, 9, 8, 32, _CANGIF1_REG
	.member	_CANMIM, 576, 9, 8, 32, _CANMIM_REG
	.member	_CANMIL, 608, 9, 8, 32, _CANMIL_REG
	.member	_CANOPC, 640, 9, 8, 32, _CANOPC_REG
	.member	_CANTIOC, 672, 9, 8, 32, _CANTIOC_REG
	.member	_CANRIOC, 704, 9, 8, 32, _CANRIOC_REG
	.member	_CANTSC, 736, 15, 8, 32
	.member	_CANTOC, 768, 9, 8, 32, _CANTOC_REG
	.member	_CANTOS, 800, 9, 8, 32, _CANTOS_REG
	.eos
	.stag	_CANMSGID_BITS, 32
	.member	_EXTMSGID_L, 0, 14, 18, 16
	.member	_EXTMSGID_H, 16, 14, 18, 2
	.member	_STDMSGID, 18, 14, 18, 11
	.member	_AAM, 29, 14, 18, 1
	.member	_AME, 30, 14, 18, 1
	.member	_IDE, 31, 14, 18, 1
	.eos
	.utag	_CANMSGID_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANMSGID_BITS
	.eos
	.stag	_CANMSGCTRL_BITS, 32
	.member	_DLC, 0, 14, 18, 4
	.member	_RTR, 4, 14, 18, 1
	.member	_rsvd1, 5, 14, 18, 3
	.member	_TPL, 8, 14, 18, 5
	.member	_rsvd2, 13, 14, 18, 3
	.member	_rsvd3, 16, 14, 18, 16
	.eos
	.utag	_CANMSGCTRL_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANMSGCTRL_BITS
	.eos
	.stag	_CANMDL_WORDS, 32
	.member	_LOW_WORD, 0, 14, 18, 16
	.member	_HI_WORD, 16, 14, 18, 16
	.eos
	.stag	_CANMDL_BYTES, 32
	.member	_BYTE3, 0, 14, 18, 8
	.member	_BYTE2, 8, 14, 18, 8
	.member	_BYTE1, 16, 14, 18, 8
	.member	_BYTE0, 24, 14, 18, 8
	.eos
	.utag	_CANMDL_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_word, 0, 8, 11, 32, _CANMDL_WORDS
	.member	_byte, 0, 8, 11, 32, _CANMDL_BYTES
	.eos
	.stag	_CANMDH_WORDS, 32
	.member	_LOW_WORD, 0, 14, 18, 16
	.member	_HI_WORD, 16, 14, 18, 16
	.eos
	.stag	_CANMDH_BYTES, 32
	.member	_BYTE7, 0, 14, 18, 8
	.member	_BYTE6, 8, 14, 18, 8
	.member	_BYTE5, 16, 14, 18, 8
	.member	_BYTE4, 24, 14, 18, 8
	.eos
	.utag	_CANMDH_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_word, 0, 8, 11, 32, _CANMDH_WORDS
	.member	_byte, 0, 8, 11, 32, _CANMDH_BYTES
	.eos
	.stag	_MBOX, 128
	.member	_MSGID, 0, 9, 8, 32, _CANMSGID_REG
	.member	_MSGCTRL, 32, 9, 8, 32, _CANMSGCTRL_REG
	.member	_MDL, 64, 9, 8, 32, _CANMDL_REG
	.member	_MDH, 96, 9, 8, 32, _CANMDH_REG
	.eos
	.stag	_ECAN_MBOXES, 4096
	.member	_MBOX0, 0, 8, 8, 128, _MBOX
	.member	_MBOX1, 128, 8, 8, 128, _MBOX
	.member	_MBOX2, 256, 8, 8, 128, _MBOX
	.member	_MBOX3, 384, 8, 8, 128, _MBOX
	.member	_MBOX4, 512, 8, 8, 128, _MBOX
	.member	_MBOX5, 640, 8, 8, 128, _MBOX
	.member	_MBOX6, 768, 8, 8, 128, _MBOX
	.member	_MBOX7, 896, 8, 8, 128, _MBOX
	.member	_MBOX8, 1024, 8, 8, 128, _MBOX
	.member	_MBOX9, 1152, 8, 8, 128, _MBOX
	.member	_MBOX10, 1280, 8, 8, 128, _MBOX
	.member	_MBOX11, 1408, 8, 8, 128, _MBOX
	.member	_MBOX12, 1536, 8, 8, 128, _MBOX
	.member	_MBOX13, 1664, 8, 8, 128, _MBOX
	.member	_MBOX14, 1792, 8, 8, 128, _MBOX
	.member	_MBOX15, 1920, 8, 8, 128, _MBOX
	.member	_MBOX16, 2048, 8, 8, 128, _MBOX
	.member	_MBOX17, 2176, 8, 8, 128, _MBOX
	.member	_MBOX18, 2304, 8, 8, 128, _MBOX
	.member	_MBOX19, 2432, 8, 8, 128, _MBOX
	.member	_MBOX20, 2560, 8, 8, 128, _MBOX
	.member	_MBOX21, 2688, 8, 8, 128, _MBOX
	.member	_MBOX22, 2816, 8, 8, 128, _MBOX
	.member	_MBOX23, 2944, 8, 8, 128, _MBOX
	.member	_MBOX24, 3072, 8, 8, 128, _MBOX
	.member	_MBOX25, 3200, 8, 8, 128, _MBOX
	.member	_MBOX26, 3328, 8, 8, 128, _MBOX
	.member	_MBOX27, 3456, 8, 8, 128, _MBOX
	.member	_MBOX28, 3584, 8, 8, 128, _MBOX
	.member	_MBOX29, 3712, 8, 8, 128, _MBOX
	.member	_MBOX30, 3840, 8, 8, 128, _MBOX
	.member	_MBOX31, 3968, 8, 8, 128, _MBOX
	.eos
	.stag	_CANLAM_BITS, 32
	.member	_LAM_L, 0, 14, 18, 16
	.member	_LAM_H, 16, 14, 18, 13
	.member	_rsvd1, 29, 14, 18, 2
	.member	_LAMI, 31, 14, 18, 1
	.eos
	.utag	_CANLAM_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _CANLAM_BITS
	.eos
	.stag	_LAM_REGS, 1024
	.member	_LAM0, 0, 9, 8, 32, _CANLAM_REG
	.member	_LAM1, 32, 9, 8, 32, _CANLAM_REG
	.member	_LAM2, 64, 9, 8, 32, _CANLAM_REG
	.member	_LAM3, 96, 9, 8, 32, _CANLAM_REG
	.member	_LAM4, 128, 9, 8, 32, _CANLAM_REG
	.member	_LAM5, 160, 9, 8, 32, _CANLAM_REG
	.member	_LAM6, 192, 9, 8, 32, _CANLAM_REG
	.member	_LAM7, 224, 9, 8, 32, _CANLAM_REG
	.member	_LAM8, 256, 9, 8, 32, _CANLAM_REG
	.member	_LAM9, 288, 9, 8, 32, _CANLAM_REG
	.member	_LAM10, 320, 9, 8, 32, _CANLAM_REG
	.member	_LAM11, 352, 9, 8, 32, _CANLAM_REG
	.member	_LAM12, 384, 9, 8, 32, _CANLAM_REG
	.member	_LAM13, 416, 9, 8, 32, _CANLAM_REG
	.member	_LAM14, 448, 9, 8, 32, _CANLAM_REG
	.member	_LAM15, 480, 9, 8, 32, _CANLAM_REG
	.member	_LAM16, 512, 9, 8, 32, _CANLAM_REG
	.member	_LAM17, 544, 9, 8, 32, _CANLAM_REG
	.member	_LAM18, 576, 9, 8, 32, _CANLAM_REG
	.member	_LAM19, 608, 9, 8, 32, _CANLAM_REG
	.member	_LAM20, 640, 9, 8, 32, _CANLAM_REG
	.member	_LAM21, 672, 9, 8, 32, _CANLAM_REG
	.member	_LAM22, 704, 9, 8, 32, _CANLAM_REG
	.member	_LAM23, 736, 9, 8, 32, _CANLAM_REG
	.member	_LAM24, 768, 9, 8, 32, _CANLAM_REG
	.member	_LAM25, 800, 9, 8, 32, _CANLAM_REG
	.member	_LAM26, 832, 9, 8, 32, _CANLAM_REG
	.member	_LAM27, 864, 9, 8, 32, _CANLAM_REG
	.member	_LAM28, 896, 9, 8, 32, _CANLAM_REG
	.member	_LAM29, 928, 9, 8, 32, _CANLAM_REG
	.member	_LAM30, 960, 9, 8, 32, _CANLAM_REG
	.member	_LAM31, 992, 9, 8, 32, _CANLAM_REG
	.eos
	.stag	_MOTS_REGS, 1024
	.member	_MOTS0, 0, 15, 8, 32
	.member	_MOTS1, 32, 15, 8, 32
	.member	_MOTS2, 64, 15, 8, 32
	.member	_MOTS3, 96, 15, 8, 32
	.member	_MOTS4, 128, 15, 8, 32
	.member	_MOTS5, 160, 15, 8, 32
	.member	_MOTS6, 192, 15, 8, 32
	.member	_MOTS7, 224, 15, 8, 32
	.member	_MOTS8, 256, 15, 8, 32
	.member	_MOTS9, 288, 15, 8, 32
	.member	_MOTS10, 320, 15, 8, 32
	.member	_MOTS11, 352, 15, 8, 32
	.member	_MOTS12, 384, 15, 8, 32
	.member	_MOTS13, 416, 15, 8, 32
	.member	_MOTS14, 448, 15, 8, 32
	.member	_MOTS15, 480, 15, 8, 32
	.member	_MOTS16, 512, 15, 8, 32
	.member	_MOTS17, 544, 15, 8, 32
	.member	_MOTS18, 576, 15, 8, 32
	.member	_MOTS19, 608, 15, 8, 32
	.member	_MOTS20, 640, 15, 8, 32
	.member	_MOTS21, 672, 15, 8, 32
	.member	_MOTS22, 704, 15, 8, 32
	.member	_MOTS23, 736, 15, 8, 32
	.member	_MOTS24, 768, 15, 8, 32
	.member	_MOTS25, 800, 15, 8, 32
	.member	_MOTS26, 832, 15, 8, 32
	.member	_MOTS27, 864, 15, 8, 32
	.member	_MOTS28, 896, 15, 8, 32
	.member	_MOTS29, 928, 15, 8, 32
	.member	_MOTS30, 960, 15, 8, 32
	.member	_MOTS31, 992, 15, 8, 32
	.eos
	.stag	_MOTO_REGS, 1024
	.member	_MOTO0, 0, 15, 8, 32
	.member	_MOTO1, 32, 15, 8, 32
	.member	_MOTO2, 64, 15, 8, 32
	.member	_MOTO3, 96, 15, 8, 32
	.member	_MOTO4, 128, 15, 8, 32
	.member	_MOTO5, 160, 15, 8, 32
	.member	_MOTO6, 192, 15, 8, 32
	.member	_MOTO7, 224, 15, 8, 32
	.member	_MOTO8, 256, 15, 8, 32
	.member	_MOTO9, 288, 15, 8, 32
	.member	_MOTO10, 320, 15, 8, 32
	.member	_MOTO11, 352, 15, 8, 32
	.member	_MOTO12, 384, 15, 8, 32
	.member	_MOTO13, 416, 15, 8, 32
	.member	_MOTO14, 448, 15, 8, 32
	.member	_MOTO15, 480, 15, 8, 32
	.member	_MOTO16, 512, 15, 8, 32
	.member	_MOTO17, 544, 15, 8, 32
	.member	_MOTO18, 576, 15, 8, 32
	.member	_MOTO19, 608, 15, 8, 32
	.member	_MOTO20, 640, 15, 8, 32
	.member	_MOTO21, 672, 15, 8, 32
	.member	_MOTO22, 704, 15, 8, 32
	.member	_MOTO23, 736, 15, 8, 32
	.member	_MOTO24, 768, 15, 8, 32
	.member	_MOTO25, 800, 15, 8, 32
	.member	_MOTO26, 832, 15, 8, 32
	.member	_MOTO27, 864, 15, 8, 32
	.member	_MOTO28, 896, 15, 8, 32
	.member	_MOTO29, 928, 15, 8, 32
	.member	_MOTO30, 960, 15, 8, 32
	.member	_MOTO31, 992, 15, 8, 32
	.eos
	.stag	_TBCTL_BITS, 16
	.member	_CTRMODE, 0, 14, 18, 2
	.member	_PHSEN, 2, 14, 18, 1
	.member	_PRDLD, 3, 14, 18, 1
	.member	_SYNCOSEL, 4, 14, 18, 2
	.member	_SWFSYNC, 6, 14, 18, 1
	.member	_HSPCLKDIV, 7, 14, 18, 3
	.member	_CLKDIV, 10, 14, 18, 3
	.member	_PHSDIR, 13, 14, 18, 1
	.member	_FREE_SOFT, 14, 14, 18, 2
	.eos
	.utag	_TBCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TBCTL_BITS
	.eos
	.stag	_TBSTS_BITS, 16
	.member	_CTRDIR, 0, 14, 18, 1
	.member	_SYNCI, 1, 14, 18, 1
	.member	_CTRMAX, 2, 14, 18, 1
	.member	_rsvd1, 3, 14, 18, 13
	.eos
	.utag	_TBSTS_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TBSTS_BITS
	.eos
	.stag	_TBPHS_HIRES_REG, 32
	.member	_TBPHSHR, 0, 14, 8, 16
	.member	_TBPHS, 16, 14, 8, 16
	.eos
	.utag	_TBPHS_HIRES_GROUP, 32
	.member	_all, 0, 15, 11, 32
	.member	_half, 0, 8, 11, 32, _TBPHS_HIRES_REG
	.eos
	.stag	_CMPCTL_BITS, 16
	.member	_LOADAMODE, 0, 14, 18, 2
	.member	_LOADBMODE, 2, 14, 18, 2
	.member	_SHDWAMODE, 4, 14, 18, 1
	.member	_rsvd1, 5, 14, 18, 1
	.member	_SHDWBMODE, 6, 14, 18, 1
	.member	_rsvd2, 7, 14, 18, 1
	.member	_SHDWAFULL, 8, 14, 18, 1
	.member	_SHDWBFULL, 9, 14, 18, 1
	.member	_rsvd3, 10, 14, 18, 6
	.eos
	.utag	_CMPCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _CMPCTL_BITS
	.eos
	.stag	_CMPA_HIRES_REG, 32
	.member	_CMPAHR, 0, 14, 8, 16
	.member	_CMPA, 16, 14, 8, 16
	.eos
	.utag	_CMPA_HIRES_GROUP, 32
	.member	_all, 0, 15, 11, 32
	.member	_half, 0, 8, 11, 32, _CMPA_HIRES_REG
	.eos
	.stag	_AQCTL_BITS, 16
	.member	_ZRO, 0, 14, 18, 2
	.member	_PRD, 2, 14, 18, 2
	.member	_CAU, 4, 14, 18, 2
	.member	_CAD, 6, 14, 18, 2
	.member	_CBU, 8, 14, 18, 2
	.member	_CBD, 10, 14, 18, 2
	.member	_rsvd, 12, 14, 18, 4
	.eos
	.utag	_AQCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _AQCTL_BITS
	.eos
	.stag	_AQSFRC_BITS, 16
	.member	_ACTSFA, 0, 14, 18, 2
	.member	_OTSFA, 2, 14, 18, 1
	.member	_ACTSFB, 3, 14, 18, 2
	.member	_OTSFB, 5, 14, 18, 1
	.member	_RLDCSF, 6, 14, 18, 2
	.member	_rsvd1, 8, 14, 18, 8
	.eos
	.utag	_AQSFRC_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _AQSFRC_BITS
	.eos
	.stag	_AQCSFRC_BITS, 16
	.member	_CSFA, 0, 14, 18, 2
	.member	_CSFB, 2, 14, 18, 2
	.member	_rsvd1, 4, 14, 18, 12
	.eos
	.utag	_AQCSFRC_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _AQCSFRC_BITS
	.eos
	.stag	_DBCTL_BITS, 16
	.member	_OUT_MODE, 0, 14, 18, 2
	.member	_POLSEL, 2, 14, 18, 2
	.member	_IN_MODE, 4, 14, 18, 2
	.member	_rsvd1, 6, 14, 18, 10
	.eos
	.utag	_DBCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _DBCTL_BITS
	.eos
	.stag	_TZSEL_BITS, 16
	.member	_CBC1, 0, 14, 18, 1
	.member	_CBC2, 1, 14, 18, 1
	.member	_CBC3, 2, 14, 18, 1
	.member	_CBC4, 3, 14, 18, 1
	.member	_CBC5, 4, 14, 18, 1
	.member	_CBC6, 5, 14, 18, 1
	.member	_rsvd1, 6, 14, 18, 2
	.member	_OSHT1, 8, 14, 18, 1
	.member	_OSHT2, 9, 14, 18, 1
	.member	_OSHT3, 10, 14, 18, 1
	.member	_OSHT4, 11, 14, 18, 1
	.member	_OSHT5, 12, 14, 18, 1
	.member	_OSHT6, 13, 14, 18, 1
	.member	_rsvd2, 14, 14, 18, 2
	.eos
	.utag	_TZSEL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TZSEL_BITS
	.eos
	.stag	_TZCTL_BITS, 16
	.member	_TZA, 0, 14, 18, 2
	.member	_TZB, 2, 14, 18, 2
	.member	_rsvd, 4, 14, 18, 12
	.eos
	.utag	_TZCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TZCTL_BITS
	.eos
	.stag	_TZEINT_BITS, 16
	.member	_rsvd1, 0, 14, 18, 1
	.member	_CBC, 1, 14, 18, 1
	.member	_OST, 2, 14, 18, 1
	.member	_rsvd2, 3, 14, 18, 13
	.eos
	.utag	_TZEINT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TZEINT_BITS
	.eos
	.stag	_TZFLG_BITS, 16
	.member	_INT, 0, 14, 18, 1
	.member	_CBC, 1, 14, 18, 1
	.member	_OST, 2, 14, 18, 1
	.member	_rsvd2, 3, 14, 18, 13
	.eos
	.utag	_TZFLG_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TZFLG_BITS
	.eos
	.stag	_TZCLR_BITS, 16
	.member	_INT, 0, 14, 18, 1
	.member	_CBC, 1, 14, 18, 1
	.member	_OST, 2, 14, 18, 1
	.member	_rsvd2, 3, 14, 18, 13
	.eos
	.utag	_TZCLR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TZCLR_BITS
	.eos
	.stag	_TZFRC_BITS, 16
	.member	_rsvd1, 0, 14, 18, 1
	.member	_CBC, 1, 14, 18, 1
	.member	_OST, 2, 14, 18, 1
	.member	_rsvd2, 3, 14, 18, 13
	.eos
	.utag	_TZFRC_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _TZFRC_BITS
	.eos
	.stag	_ETSEL_BITS, 16
	.member	_INTSEL, 0, 14, 18, 3
	.member	_INTEN, 3, 14, 18, 1
	.member	_rsvd1, 4, 14, 18, 4
	.member	_SOCASEL, 8, 14, 18, 3
	.member	_SOCAEN, 11, 14, 18, 1
	.member	_SOCBSEL, 12, 14, 18, 3
	.member	_SOCBEN, 15, 14, 18, 1
	.eos
	.utag	_ETSEL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ETSEL_BITS
	.eos
	.stag	_ETPS_BITS, 16
	.member	_INTPRD, 0, 14, 18, 2
	.member	_INTCNT, 2, 14, 18, 2
	.member	_rsvd1, 4, 14, 18, 4
	.member	_SOCAPRD, 8, 14, 18, 2
	.member	_SOCACNT, 10, 14, 18, 2
	.member	_SOCBPRD, 12, 14, 18, 2
	.member	_SOCBCNT, 14, 14, 18, 2
	.eos
	.utag	_ETPS_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ETPS_BITS
	.eos
	.stag	_ETFLG_BITS, 16
	.member	_INT, 0, 14, 18, 1
	.member	_rsvd1, 1, 14, 18, 1
	.member	_SOCA, 2, 14, 18, 1
	.member	_SOCB, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 12
	.eos
	.utag	_ETFLG_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ETFLG_BITS
	.eos
	.stag	_ETCLR_BITS, 16
	.member	_INT, 0, 14, 18, 1
	.member	_rsvd1, 1, 14, 18, 1
	.member	_SOCA, 2, 14, 18, 1
	.member	_SOCB, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 12
	.eos
	.utag	_ETCLR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ETCLR_BITS
	.eos
	.stag	_ETFRC_BITS, 16
	.member	_INT, 0, 14, 18, 1
	.member	_rsvd1, 1, 14, 18, 1
	.member	_SOCA, 2, 14, 18, 1
	.member	_SOCB, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 12
	.eos
	.utag	_ETFRC_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ETFRC_BITS
	.eos
	.stag	_PCCTL_BITS, 16
	.member	_CHPEN, 0, 14, 18, 1
	.member	_OSHTWTH, 1, 14, 18, 4
	.member	_CHPFREQ, 5, 14, 18, 3
	.member	_CHPDUTY, 8, 14, 18, 3
	.member	_rsvd1, 11, 14, 18, 5
	.eos
	.utag	_PCCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PCCTL_BITS
	.eos
	.stag	_HRCNFG_BITS, 16
	.member	_EDGMODE, 0, 14, 18, 2
	.member	_CTLMODE, 2, 14, 18, 1
	.member	_HRLOAD, 3, 14, 18, 1
	.member	_rsvd1, 4, 14, 18, 12
	.eos
	.utag	_HRCNFG_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _HRCNFG_BITS
	.eos
	.stag	_EPWM_REGS, 544
	.member	_TBCTL, 0, 9, 8, 16, _TBCTL_REG
	.member	_TBSTS, 16, 9, 8, 16, _TBSTS_REG
	.member	_TBPHS, 32, 9, 8, 32, _TBPHS_HIRES_GROUP
	.member	_TBCTR, 64, 14, 8, 16
	.member	_TBPRD, 80, 14, 8, 16
	.member	_rsvd1, 96, 14, 8, 16
	.member	_CMPCTL, 112, 9, 8, 16, _CMPCTL_REG
	.member	_CMPA, 128, 9, 8, 32, _CMPA_HIRES_GROUP
	.member	_CMPB, 160, 14, 8, 16
	.member	_AQCTLA, 176, 9, 8, 16, _AQCTL_REG
	.member	_AQCTLB, 192, 9, 8, 16, _AQCTL_REG
	.member	_AQSFRC, 208, 9, 8, 16, _AQSFRC_REG
	.member	_AQCSFRC, 224, 9, 8, 16, _AQCSFRC_REG
	.member	_DBCTL, 240, 9, 8, 16, _DBCTL_REG
	.member	_DBRED, 256, 14, 8, 16
	.member	_DBFED, 272, 14, 8, 16
	.member	_TZSEL, 288, 9, 8, 16, _TZSEL_REG
	.member	_rsvd2, 304, 14, 8, 16
	.member	_TZCTL, 320, 9, 8, 16, _TZCTL_REG
	.member	_TZEINT, 336, 9, 8, 16, _TZEINT_REG
	.member	_TZFLG, 352, 9, 8, 16, _TZFLG_REG
	.member	_TZCLR, 368, 9, 8, 16, _TZCLR_REG
	.member	_TZFRC, 384, 9, 8, 16, _TZFRC_REG
	.member	_ETSEL, 400, 9, 8, 16, _ETSEL_REG
	.member	_ETPS, 416, 9, 8, 16, _ETPS_REG
	.member	_ETFLG, 432, 9, 8, 16, _ETFLG_REG
	.member	_ETCLR, 448, 9, 8, 16, _ETCLR_REG
	.member	_ETFRC, 464, 9, 8, 16, _ETFRC_REG
	.member	_PCCTL, 480, 9, 8, 16, _PCCTL_REG
	.member	_rsvd3, 496, 14, 8, 16
	.member	_HRCNFG, 512, 9, 8, 16, _HRCNFG_REG
	.eos
	.stag	_ECCTL1_BITS, 16
	.member	_CAP1POL, 0, 14, 18, 1
	.member	_CTRRST1, 1, 14, 18, 1
	.member	_CAP2POL, 2, 14, 18, 1
	.member	_CTRRST2, 3, 14, 18, 1
	.member	_CAP3POL, 4, 14, 18, 1
	.member	_CTRRST3, 5, 14, 18, 1
	.member	_CAP4POL, 6, 14, 18, 1
	.member	_CTRRST4, 7, 14, 18, 1
	.member	_CAPLDEN, 8, 14, 18, 1
	.member	_PRESCALE, 9, 14, 18, 5
	.member	_FREE_SOFT, 14, 14, 18, 2
	.eos
	.utag	_ECCTL1_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ECCTL1_BITS
	.eos
	.stag	_ECCTL2_BITS, 16
	.member	_CONT_ONESHT, 0, 14, 18, 1
	.member	_STOP_WRAP, 1, 14, 18, 2
	.member	_REARM, 3, 14, 18, 1
	.member	_TSCTRSTOP, 4, 14, 18, 1
	.member	_SYNCI_EN, 5, 14, 18, 1
	.member	_SYNCO_SEL, 6, 14, 18, 2
	.member	_SWSYNC, 8, 14, 18, 1
	.member	_CAP_APWM, 9, 14, 18, 1
	.member	_APWMPOL, 10, 14, 18, 1
	.member	_rsvd1, 11, 14, 18, 5
	.eos
	.utag	_ECCTL2_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ECCTL2_BITS
	.eos
	.stag	_ECEINT_BITS, 16
	.member	_rsvd1, 0, 14, 18, 1
	.member	_CEVT1, 1, 14, 18, 1
	.member	_CEVT2, 2, 14, 18, 1
	.member	_CEVT3, 3, 14, 18, 1
	.member	_CEVT4, 4, 14, 18, 1
	.member	_CTROVF, 5, 14, 18, 1
	.member	_CTR_EQ_PRD, 6, 14, 18, 1
	.member	_CTR_EQ_CMP, 7, 14, 18, 1
	.member	_rsvd2, 8, 14, 18, 8
	.eos
	.utag	_ECEINT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ECEINT_BITS
	.eos
	.stag	_ECFLG_BITS, 16
	.member	_INT, 0, 14, 18, 1
	.member	_CEVT1, 1, 14, 18, 1
	.member	_CEVT2, 2, 14, 18, 1
	.member	_CEVT3, 3, 14, 18, 1
	.member	_CEVT4, 4, 14, 18, 1
	.member	_CTROVF, 5, 14, 18, 1
	.member	_CTR_EQ_PRD, 6, 14, 18, 1
	.member	_CTR_EQ_CMP, 7, 14, 18, 1
	.member	_rsvd2, 8, 14, 18, 8
	.eos
	.utag	_ECFLG_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _ECFLG_BITS
	.eos
	.stag	_ECAP_REGS, 512
	.member	_TSCTR, 0, 15, 8, 32
	.member	_CTRPHS, 32, 15, 8, 32
	.member	_CAP1, 64, 15, 8, 32
	.member	_CAP2, 96, 15, 8, 32
	.member	_CAP3, 128, 15, 8, 32
	.member	_CAP4, 160, 15, 8, 32
	.member	_rsvd1, 192, 62, 8, 128, , 8
	.member	_ECCTL1, 320, 9, 8, 16, _ECCTL1_REG
	.member	_ECCTL2, 336, 9, 8, 16, _ECCTL2_REG
	.member	_ECEINT, 352, 9, 8, 16, _ECEINT_REG
	.member	_ECFLG, 368, 9, 8, 16, _ECFLG_REG
	.member	_ECCLR, 384, 9, 8, 16, _ECFLG_REG
	.member	_ECFRC, 400, 9, 8, 16, _ECEINT_REG
	.member	_rsvd2, 416, 62, 8, 96, , 6
	.eos
	.stag	_QDECCTL_BITS, 16
	.member	_rsvd1, 0, 14, 18, 5
	.member	_QSP, 5, 14, 18, 1
	.member	_QIP, 6, 14, 18, 1
	.member	_QBP, 7, 14, 18, 1
	.member	_QAP, 8, 14, 18, 1
	.member	_IGATE, 9, 14, 18, 1
	.member	_SWAP, 10, 14, 18, 1
	.member	_XCR, 11, 14, 18, 1
	.member	_SPSEL, 12, 14, 18, 1
	.member	_SOEN, 13, 14, 18, 1
	.member	_QSRC, 14, 14, 18, 2
	.eos
	.utag	_QDECCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QDECCTL_BITS
	.eos
	.stag	_QEPCTL_BITS, 16
	.member	_WDE, 0, 14, 18, 1
	.member	_UTE, 1, 14, 18, 1
	.member	_QCLM, 2, 14, 18, 1
	.member	_QPEN, 3, 14, 18, 1
	.member	_IEL, 4, 14, 18, 2
	.member	_SEL, 6, 14, 18, 1
	.member	_SWI, 7, 14, 18, 1
	.member	_IEI, 8, 14, 18, 2
	.member	_SEI, 10, 14, 18, 2
	.member	_PCRM, 12, 14, 18, 2
	.member	_FREE_SOFT, 14, 14, 18, 2
	.eos
	.utag	_QEPCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QEPCTL_BITS
	.eos
	.stag	_QCAPCTL_BITS, 16
	.member	_UPPS, 0, 14, 18, 4
	.member	_CCPS, 4, 14, 18, 3
	.member	_rsvd1, 7, 14, 18, 8
	.member	_CEN, 15, 14, 18, 1
	.eos
	.utag	_QCAPCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QCAPCTL_BITS
	.eos
	.stag	_QPOSCTL_BITS, 16
	.member	_PCSPW, 0, 14, 18, 12
	.member	_PCE, 12, 14, 18, 1
	.member	_PCPOL, 13, 14, 18, 1
	.member	_PCLOAD, 14, 14, 18, 1
	.member	_PCSHDW, 15, 14, 18, 1
	.eos
	.utag	_QPOSCTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QPOSCTL_BITS
	.eos
	.stag	_QEINT_BITS, 16
	.member	_rsvd1, 0, 14, 18, 1
	.member	_PCE, 1, 14, 18, 1
	.member	_QPE, 2, 14, 18, 1
	.member	_QDC, 3, 14, 18, 1
	.member	_WTO, 4, 14, 18, 1
	.member	_PCU, 5, 14, 18, 1
	.member	_PCO, 6, 14, 18, 1
	.member	_PCR, 7, 14, 18, 1
	.member	_PCM, 8, 14, 18, 1
	.member	_SEL, 9, 14, 18, 1
	.member	_IEL, 10, 14, 18, 1
	.member	_UTO, 11, 14, 18, 1
	.member	_rsvd2, 12, 14, 18, 4
	.eos
	.utag	_QEINT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QEINT_BITS
	.eos
	.stag	_QFLG_BITS, 16
	.member	_INT, 0, 14, 18, 1
	.member	_PCE, 1, 14, 18, 1
	.member	_PHE, 2, 14, 18, 1
	.member	_QDC, 3, 14, 18, 1
	.member	_WTO, 4, 14, 18, 1
	.member	_PCU, 5, 14, 18, 1
	.member	_PCO, 6, 14, 18, 1
	.member	_PCR, 7, 14, 18, 1
	.member	_PCM, 8, 14, 18, 1
	.member	_SEL, 9, 14, 18, 1
	.member	_IEL, 10, 14, 18, 1
	.member	_UTO, 11, 14, 18, 1
	.member	_rsvd2, 12, 14, 18, 4
	.eos
	.utag	_QFLG_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QFLG_BITS
	.eos
	.stag	_QFRC_BITS, 16
	.member	_reserved, 0, 14, 18, 1
	.member	_PCE, 1, 14, 18, 1
	.member	_PHE, 2, 14, 18, 1
	.member	_QDC, 3, 14, 18, 1
	.member	_WTO, 4, 14, 18, 1
	.member	_PCU, 5, 14, 18, 1
	.member	_PCO, 6, 14, 18, 1
	.member	_PCR, 7, 14, 18, 1
	.member	_PCM, 8, 14, 18, 1
	.member	_SEL, 9, 14, 18, 1
	.member	_IEL, 10, 14, 18, 1
	.member	_UTO, 11, 14, 18, 1
	.member	_rsvd2, 12, 14, 18, 4
	.eos
	.utag	_QFRC_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QFRC_BITS
	.eos
	.stag	_QEPSTS_BITS, 16
	.member	_PCEF, 0, 14, 18, 1
	.member	_FIMF, 1, 14, 18, 1
	.member	_CDEF, 2, 14, 18, 1
	.member	_COEF, 3, 14, 18, 1
	.member	_QDLF, 4, 14, 18, 1
	.member	_QDF, 5, 14, 18, 1
	.member	_FIDF, 6, 14, 18, 1
	.member	_UPEVNT, 7, 14, 18, 1
	.member	_rsvd1, 8, 14, 18, 8
	.eos
	.utag	_QEPSTS_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _QEPSTS_BITS
	.eos
	.stag	_EQEP_REGS, 1024
	.member	_QPOSCNT, 0, 15, 8, 32
	.member	_QPOSINIT, 32, 15, 8, 32
	.member	_QPOSMAX, 64, 15, 8, 32
	.member	_QPOSCMP, 96, 15, 8, 32
	.member	_QPOSILAT, 128, 15, 8, 32
	.member	_QPOSSLAT, 160, 15, 8, 32
	.member	_QPOSLAT, 192, 15, 8, 32
	.member	_QUTMR, 224, 15, 8, 32
	.member	_QUPRD, 256, 15, 8, 32
	.member	_QWDTMR, 288, 14, 8, 16
	.member	_QWDPRD, 304, 14, 8, 16
	.member	_QDECCTL, 320, 9, 8, 16, _QDECCTL_REG
	.member	_QEPCTL, 336, 9, 8, 16, _QEPCTL_REG
	.member	_QCAPCTL, 352, 9, 8, 16, _QCAPCTL_REG
	.member	_QPOSCTL, 368, 9, 8, 16, _QPOSCTL_REG
	.member	_QEINT, 384, 9, 8, 16, _QEINT_REG
	.member	_QFLG, 400, 9, 8, 16, _QFLG_REG
	.member	_QCLR, 416, 9, 8, 16, _QFLG_REG
	.member	_QFRC, 432, 9, 8, 16, _QFRC_REG
	.member	_QEPSTS, 448, 9, 8, 16, _QEPSTS_REG
	.member	_QCTMR, 464, 14, 8, 16
	.member	_QCPRD, 480, 14, 8, 16
	.member	_QCTMRLAT, 496, 14, 8, 16
	.member	_QCPRDLAT, 512, 14, 8, 16
	.member	_rsvd1, 528, 62, 8, 480, , 30
	.eos
	.stag	_GPACTRL_BITS, 32
	.member	_QUALPRD0, 0, 14, 18, 8
	.member	_QUALPRD1, 8, 14, 18, 8
	.member	_QUALPRD2, 16, 14, 18, 8
	.member	_QUALPRD3, 24, 14, 18, 8
	.eos
	.utag	_GPACTRL_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPACTRL_BITS
	.eos
	.stag	_GPA1_BITS, 32
	.member	_GPIO0, 0, 14, 18, 2
	.member	_GPIO1, 2, 14, 18, 2
	.member	_GPIO2, 4, 14, 18, 2
	.member	_GPIO3, 6, 14, 18, 2
	.member	_GPIO4, 8, 14, 18, 2
	.member	_GPIO5, 10, 14, 18, 2
	.member	_GPIO6, 12, 14, 18, 2
	.member	_GPIO7, 14, 14, 18, 2
	.member	_GPIO8, 16, 14, 18, 2
	.member	_GPIO9, 18, 14, 18, 2
	.member	_GPIO10, 20, 14, 18, 2
	.member	_GPIO11, 22, 14, 18, 2
	.member	_GPIO12, 24, 14, 18, 2
	.member	_GPIO13, 26, 14, 18, 2
	.member	_GPIO14, 28, 14, 18, 2
	.member	_GPIO15, 30, 14, 18, 2
	.eos
	.utag	_GPA1_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPA1_BITS
	.eos
	.stag	_GPA2_BITS, 32
	.member	_GPIO16, 0, 14, 18, 2
	.member	_GPIO17, 2, 14, 18, 2
	.member	_GPIO18, 4, 14, 18, 2
	.member	_GPIO19, 6, 14, 18, 2
	.member	_GPIO20, 8, 14, 18, 2
	.member	_GPIO21, 10, 14, 18, 2
	.member	_GPIO22, 12, 14, 18, 2
	.member	_GPIO23, 14, 14, 18, 2
	.member	_GPIO24, 16, 14, 18, 2
	.member	_GPIO25, 18, 14, 18, 2
	.member	_GPIO26, 20, 14, 18, 2
	.member	_GPIO27, 22, 14, 18, 2
	.member	_GPIO28, 24, 14, 18, 2
	.member	_GPIO29, 26, 14, 18, 2
	.member	_GPIO30, 28, 14, 18, 2
	.member	_GPIO31, 30, 14, 18, 2
	.eos
	.utag	_GPA2_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPA2_BITS
	.eos
	.stag	_GPADAT_BITS, 32
	.member	_GPIO0, 0, 14, 18, 1
	.member	_GPIO1, 1, 14, 18, 1
	.member	_GPIO2, 2, 14, 18, 1
	.member	_GPIO3, 3, 14, 18, 1
	.member	_GPIO4, 4, 14, 18, 1
	.member	_GPIO5, 5, 14, 18, 1
	.member	_GPIO6, 6, 14, 18, 1
	.member	_GPIO7, 7, 14, 18, 1
	.member	_GPIO8, 8, 14, 18, 1
	.member	_GPIO9, 9, 14, 18, 1
	.member	_GPIO10, 10, 14, 18, 1
	.member	_GPIO11, 11, 14, 18, 1
	.member	_GPIO12, 12, 14, 18, 1
	.member	_GPIO13, 13, 14, 18, 1
	.member	_GPIO14, 14, 14, 18, 1
	.member	_GPIO15, 15, 14, 18, 1
	.member	_GPIO16, 16, 14, 18, 1
	.member	_GPIO17, 17, 14, 18, 1
	.member	_GPIO18, 18, 14, 18, 1
	.member	_GPIO19, 19, 14, 18, 1
	.member	_GPIO20, 20, 14, 18, 1
	.member	_GPIO21, 21, 14, 18, 1
	.member	_GPIO22, 22, 14, 18, 1
	.member	_GPIO23, 23, 14, 18, 1
	.member	_GPIO24, 24, 14, 18, 1
	.member	_GPIO25, 25, 14, 18, 1
	.member	_GPIO26, 26, 14, 18, 1
	.member	_GPIO27, 27, 14, 18, 1
	.member	_GPIO28, 28, 14, 18, 1
	.member	_GPIO29, 29, 14, 18, 1
	.member	_GPIO30, 30, 14, 18, 1
	.member	_GPIO31, 31, 14, 18, 1
	.eos
	.utag	_GPADAT_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPADAT_BITS
	.eos
	.stag	_GPBCTRL_BITS, 32
	.member	_QUALPRD0, 0, 14, 18, 8
	.member	_rsvd1, 8, 14, 18, 8
	.member	_rsvd2, 16, 14, 18, 16
	.eos
	.utag	_GPBCTRL_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPBCTRL_BITS
	.eos
	.stag	_GPB1_BITS, 32
	.member	_GPIO32, 0, 14, 18, 2
	.member	_GPIO33, 2, 14, 18, 2
	.member	_GPIO34, 4, 14, 18, 2
	.member	_rsvd1, 6, 14, 18, 2
	.member	_rsvd2, 8, 14, 18, 8
	.member	_rsvd3, 16, 14, 18, 16
	.eos
	.utag	_GPB1_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPB1_BITS
	.eos
	.stag	_GPB2_BITS, 32
	.member	_rsvd1, 0, 14, 18, 16
	.member	_rsvd2, 16, 14, 18, 16
	.eos
	.utag	_GPB2_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPB2_BITS
	.eos
	.stag	_GPBDAT_BITS, 32
	.member	_GPIO32, 0, 14, 18, 1
	.member	_GPIO33, 1, 14, 18, 1
	.member	_GPIO34, 2, 14, 18, 1
	.member	_rsvd1, 3, 14, 18, 1
	.member	_rsvd2, 4, 14, 18, 12
	.member	_rsvd3, 16, 14, 18, 16
	.eos
	.utag	_GPBDAT_REG, 32
	.member	_all, 0, 15, 11, 32
	.member	_bit, 0, 8, 11, 32, _GPBDAT_BITS
	.eos
	.stag	_GPIO_CTRL_REGS, 1024
	.member	_GPACTRL, 0, 9, 8, 32, _GPACTRL_REG
	.member	_GPAQSEL1, 32, 9, 8, 32, _GPA1_REG
	.member	_GPAQSEL2, 64, 9, 8, 32, _GPA2_REG
	.member	_GPAMUX1, 96, 9, 8, 32, _GPA1_REG
	.member	_GPAMUX2, 128, 9, 8, 32, _GPA2_REG
	.member	_GPADIR, 160, 9, 8, 32, _GPADAT_REG
	.member	_GPAPUD, 192, 9, 8, 32, _GPADAT_REG
	.member	_rsvd1, 224, 15, 8, 32
	.member	_GPBCTRL, 256, 9, 8, 32, _GPBCTRL_REG
	.member	_GPBQSEL1, 288, 9, 8, 32, _GPB1_REG
	.member	_GPBQSEL2, 320, 9, 8, 32, _GPB2_REG
	.member	_GPBMUX1, 352, 9, 8, 32, _GPB1_REG
	.member	_GPBMUX2, 384, 9, 8, 32, _GPB2_REG
	.member	_GPBDIR, 416, 9, 8, 32, _GPBDAT_REG
	.member	_GPBPUD, 448, 9, 8, 32, _GPBDAT_REG
	.member	_rsvd2, 480, 62, 8, 528, , 33
	.eos
	.stag	_GPIO_DATA_REGS, 512
	.member	_GPADAT, 0, 9, 8, 32, _GPADAT_REG
	.member	_GPASET, 32, 9, 8, 32, _GPADAT_REG
	.member	_GPACLEAR, 64, 9, 8, 32, _GPADAT_REG
	.member	_GPATOGGLE, 96, 9, 8, 32, _GPADAT_REG
	.member	_GPBDAT, 128, 9, 8, 32, _GPBDAT_REG
	.member	_GPBSET, 160, 9, 8, 32, _GPBDAT_REG
	.member	_GPBCLEAR, 192, 9, 8, 32, _GPBDAT_REG
	.member	_GPBTOGGLE, 224, 9, 8, 32, _GPBDAT_REG
	.member	_rsvd1, 256, 62, 8, 256, , 16
	.eos
	.stag	_GPIOXINT_BITS, 16
	.member	_GPIOSEL, 0, 14, 18, 5
	.member	_rsvd1, 5, 14, 18, 11
	.eos
	.utag	_GPIOXINT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _GPIOXINT_BITS
	.eos
	.stag	_GPIO_INT_REGS, 160
	.member	_GPIOXINT1SEL, 0, 9, 8, 16, _GPIOXINT_REG
	.member	_GPIOXINT2SEL, 16, 9, 8, 16, _GPIOXINT_REG
	.member	_GPIOXNMISEL, 32, 9, 8, 16, _GPIOXINT_REG
	.member	_rsvd2, 48, 62, 8, 80, , 5
	.member	_GPIOLPMSEL, 128, 9, 8, 32, _GPADAT_REG
	.eos
	.stag	_I2CIER_BITS, 16
	.member	_AL, 0, 14, 18, 1
	.member	_NACK, 1, 14, 18, 1
	.member	_ARDY, 2, 14, 18, 1
	.member	_RRDY, 3, 14, 18, 1
	.member	_XRDY, 4, 14, 18, 1
	.member	_SCD, 5, 14, 18, 1
	.member	_AAS, 6, 14, 18, 1
	.member	_rsvd, 7, 14, 18, 9
	.eos
	.utag	_I2CIER_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _I2CIER_BITS
	.eos
	.stag	_I2CSTR_BITS, 16
	.member	_AL, 0, 14, 18, 1
	.member	_NACK, 1, 14, 18, 1
	.member	_ARDY, 2, 14, 18, 1
	.member	_RRDY, 3, 14, 18, 1
	.member	_XRDY, 4, 14, 18, 1
	.member	_SCD, 5, 14, 18, 1
	.member	_rsvd1, 6, 14, 18, 2
	.member	_AD0, 8, 14, 18, 1
	.member	_AAS, 9, 14, 18, 1
	.member	_XSMT, 10, 14, 18, 1
	.member	_RSFULL, 11, 14, 18, 1
	.member	_BB, 12, 14, 18, 1
	.member	_NACKSNT, 13, 14, 18, 1
	.member	_SDIR, 14, 14, 18, 1
	.member	_rsvd2, 15, 14, 18, 1
	.eos
	.utag	_I2CSTR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _I2CSTR_BITS
	.eos
	.stag	_I2CMDR_BITS, 16
	.member	_BC, 0, 14, 18, 3
	.member	_FDF, 3, 14, 18, 1
	.member	_STB, 4, 14, 18, 1
	.member	_IRS, 5, 14, 18, 1
	.member	_DLB, 6, 14, 18, 1
	.member	_RM, 7, 14, 18, 1
	.member	_XA, 8, 14, 18, 1
	.member	_TRX, 9, 14, 18, 1
	.member	_MST, 10, 14, 18, 1
	.member	_STP, 11, 14, 18, 1
	.member	_rsvd1, 12, 14, 18, 1
	.member	_STT, 13, 14, 18, 1
	.member	_FREE, 14, 14, 18, 1
	.member	_NACKMOD, 15, 14, 18, 1
	.eos
	.utag	_I2CMDR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _I2CMDR_BITS
	.eos
	.stag	_I2CISRC_BITS, 16
	.member	_INTCODE, 0, 14, 18, 3
	.member	_rsvd1, 3, 14, 18, 13
	.eos
	.utag	_I2CISRC_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _I2CISRC_BITS
	.eos
	.stag	_I2CPSC_BITS, 16
	.member	_IPSC, 0, 14, 18, 8
	.member	_rsvd1, 8, 14, 18, 8
	.eos
	.utag	_I2CPSC_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _I2CPSC_BITS
	.eos
	.stag	_I2CFFTX_BITS, 16
	.member	_TXFFIL, 0, 14, 18, 5
	.member	_TXFFIENA, 5, 14, 18, 1
	.member	_TXFFINTCLR, 6, 14, 18, 1
	.member	_TXFFINT, 7, 14, 18, 1
	.member	_TXFFST, 8, 14, 18, 5
	.member	_TXFFRST, 13, 14, 18, 1
	.member	_I2CFFEN, 14, 14, 18, 1
	.member	_rsvd1, 15, 14, 18, 1
	.eos
	.utag	_I2CFFTX_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _I2CFFTX_BITS
	.eos
	.stag	_I2CFFRX_BITS, 16
	.member	_RXFFIL, 0, 14, 18, 5
	.member	_RXFFIENA, 5, 14, 18, 1
	.member	_RXFFINTCLR, 6, 14, 18, 1
	.member	_RXFFINT, 7, 14, 18, 1
	.member	_RXFFST, 8, 14, 18, 5
	.member	_RXFFRST, 13, 14, 18, 1
	.member	_rsvd1, 14, 14, 18, 2
	.eos
	.utag	_I2CFFRX_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _I2CFFRX_BITS
	.eos
	.stag	_I2C_REGS, 544
	.member	_I2COAR, 0, 14, 8, 16
	.member	_I2CIER, 16, 9, 8, 16, _I2CIER_REG
	.member	_I2CSTR, 32, 9, 8, 16, _I2CSTR_REG
	.member	_I2CCLKL, 48, 14, 8, 16
	.member	_I2CCLKH, 64, 14, 8, 16
	.member	_I2CCNT, 80, 14, 8, 16
	.member	_I2CDRR, 96, 14, 8, 16
	.member	_I2CSAR, 112, 14, 8, 16
	.member	_I2CDXR, 128, 14, 8, 16
	.member	_I2CMDR, 144, 9, 8, 16, _I2CMDR_REG
	.member	_I2CISRC, 160, 9, 8, 16, _I2CISRC_REG
	.member	_rsvd1, 176, 14, 8, 16
	.member	_I2CPSC, 192, 9, 8, 16, _I2CPSC_REG
	.member	_rsvd2, 208, 62, 8, 304, , 19
	.member	_I2CFFTX, 512, 9, 8, 16, _I2CFFTX_REG
	.member	_I2CFFRX, 528, 9, 8, 16, _I2CFFRX_REG
	.eos
	.stag	_PIECTRL_BITS, 16
	.member	_ENPIE, 0, 14, 18, 1
	.member	_PIEVECT, 1, 14, 18, 15
	.eos
	.utag	_PIECTRL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PIECTRL_BITS
	.eos
	.stag	_PIEACK_BITS, 16
	.member	_ACK1, 0, 14, 18, 1
	.member	_ACK2, 1, 14, 18, 1
	.member	_ACK3, 2, 14, 18, 1
	.member	_ACK4, 3, 14, 18, 1
	.member	_ACK5, 4, 14, 18, 1
	.member	_ACK6, 5, 14, 18, 1
	.member	_ACK7, 6, 14, 18, 1
	.member	_ACK8, 7, 14, 18, 1
	.member	_ACK9, 8, 14, 18, 1
	.member	_ACK10, 9, 14, 18, 1
	.member	_ACK11, 10, 14, 18, 1
	.member	_ACK12, 11, 14, 18, 1
	.member	_rsvd, 12, 14, 18, 4
	.eos
	.utag	_PIEACK_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PIEACK_BITS
	.eos
	.stag	_PIEIER_BITS, 16
	.member	_INTx1, 0, 14, 18, 1
	.member	_INTx2, 1, 14, 18, 1
	.member	_INTx3, 2, 14, 18, 1
	.member	_INTx4, 3, 14, 18, 1
	.member	_INTx5, 4, 14, 18, 1
	.member	_INTx6, 5, 14, 18, 1
	.member	_INTx7, 6, 14, 18, 1
	.member	_INTx8, 7, 14, 18, 1
	.member	_rsvd, 8, 14, 18, 8
	.eos
	.utag	_PIEIER_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PIEIER_BITS
	.eos
	.stag	_PIEIFR_BITS, 16
	.member	_INTx1, 0, 14, 18, 1
	.member	_INTx2, 1, 14, 18, 1
	.member	_INTx3, 2, 14, 18, 1
	.member	_INTx4, 3, 14, 18, 1
	.member	_INTx5, 4, 14, 18, 1
	.member	_INTx6, 5, 14, 18, 1
	.member	_INTx7, 6, 14, 18, 1
	.member	_INTx8, 7, 14, 18, 1
	.member	_rsvd, 8, 14, 18, 8
	.eos
	.utag	_PIEIFR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PIEIFR_BITS
	.eos
	.stag	_PIE_CTRL_REGS, 416
	.member	_PIECTRL, 0, 9, 8, 16, _PIECTRL_REG
	.member	_PIEACK, 16, 9, 8, 16, _PIEACK_REG
	.member	_PIEIER1, 32, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR1, 48, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER2, 64, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR2, 80, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER3, 96, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR3, 112, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER4, 128, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR4, 144, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER5, 160, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR5, 176, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER6, 192, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR6, 208, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER7, 224, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR7, 240, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER8, 256, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR8, 272, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER9, 288, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR9, 304, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER10, 320, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR10, 336, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER11, 352, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR11, 368, 9, 8, 16, _PIEIFR_REG
	.member	_PIEIER12, 384, 9, 8, 16, _PIEIER_REG
	.member	_PIEIFR12, 400, 9, 8, 16, _PIEIFR_REG
	.eos
	.stag	_PIE_VECT_TABLE, 4096
	.member	_PIE1_RESERVED, 0, 144, 8, 22
	.member	_PIE2_RESERVED, 32, 144, 8, 22
	.member	_PIE3_RESERVED, 64, 144, 8, 22
	.member	_PIE4_RESERVED, 96, 144, 8, 22
	.member	_PIE5_RESERVED, 128, 144, 8, 22
	.member	_PIE6_RESERVED, 160, 144, 8, 22
	.member	_PIE7_RESERVED, 192, 144, 8, 22
	.member	_PIE8_RESERVED, 224, 144, 8, 22
	.member	_PIE9_RESERVED, 256, 144, 8, 22
	.member	_PIE10_RESERVED, 288, 144, 8, 22
	.member	_PIE11_RESERVED, 320, 144, 8, 22
	.member	_PIE12_RESERVED, 352, 144, 8, 22
	.member	_PIE13_RESERVED, 384, 144, 8, 22
	.member	_XINT13, 416, 144, 8, 22
	.member	_TINT2, 448, 144, 8, 22
	.member	_DATALOG, 480, 144, 8, 22
	.member	_RTOSINT, 512, 144, 8, 22
	.member	_EMUINT, 544, 144, 8, 22
	.member	_XNMI, 576, 144, 8, 22
	.member	_ILLEGAL, 608, 144, 8, 22
	.member	_USER1, 640, 144, 8, 22
	.member	_USER2, 672, 144, 8, 22
	.member	_USER3, 704, 144, 8, 22
	.member	_USER4, 736, 144, 8, 22
	.member	_USER5, 768, 144, 8, 22
	.member	_USER6, 800, 144, 8, 22
	.member	_USER7, 832, 144, 8, 22
	.member	_USER8, 864, 144, 8, 22
	.member	_USER9, 896, 144, 8, 22
	.member	_USER10, 928, 144, 8, 22
	.member	_USER11, 960, 144, 8, 22
	.member	_USER12, 992, 144, 8, 22
	.member	_SEQ1INT, 1024, 144, 8, 22
	.member	_SEQ2INT, 1056, 144, 8, 22
	.member	_rsvd1_3, 1088, 144, 8, 22
	.member	_XINT1, 1120, 144, 8, 22
	.member	_XINT2, 1152, 144, 8, 22
	.member	_ADCINT, 1184, 144, 8, 22
	.member	_TINT0, 1216, 144, 8, 22
	.member	_WAKEINT, 1248, 144, 8, 22
	.member	_EPWM1_TZINT, 1280, 144, 8, 22
	.member	_EPWM2_TZINT, 1312, 144, 8, 22
	.member	_EPWM3_TZINT, 1344, 144, 8, 22
	.member	_EPWM4_TZINT, 1376, 144, 8, 22
	.member	_EPWM5_TZINT, 1408, 144, 8, 22
	.member	_EPWM6_TZINT, 1440, 144, 8, 22
	.member	_rsvd2_7, 1472, 144, 8, 22
	.member	_rsvd2_8, 1504, 144, 8, 22
	.member	_EPWM1_INT, 1536, 144, 8, 22
	.member	_EPWM2_INT, 1568, 144, 8, 22
	.member	_EPWM3_INT, 1600, 144, 8, 22
	.member	_EPWM4_INT, 1632, 144, 8, 22
	.member	_EPWM5_INT, 1664, 144, 8, 22
	.member	_EPWM6_INT, 1696, 144, 8, 22
	.member	_rsvd3_7, 1728, 144, 8, 22
	.member	_rsvd3_8, 1760, 144, 8, 22
	.member	_ECAP1_INT, 1792, 144, 8, 22
	.member	_ECAP2_INT, 1824, 144, 8, 22
	.member	_ECAP3_INT, 1856, 144, 8, 22
	.member	_ECAP4_INT, 1888, 144, 8, 22
	.member	_rsvd4_5, 1920, 144, 8, 22
	.member	_rsvd4_6, 1952, 144, 8, 22
	.member	_rsvd4_7, 1984, 144, 8, 22
	.member	_rsvd4_8, 2016, 144, 8, 22
	.member	_EQEP1_INT, 2048, 144, 8, 22
	.member	_EQEP2_INT, 2080, 144, 8, 22
	.member	_rsvd5_3, 2112, 144, 8, 22
	.member	_rsvd5_4, 2144, 144, 8, 22
	.member	_rsvd5_5, 2176, 144, 8, 22
	.member	_rsvd5_6, 2208, 144, 8, 22
	.member	_rsvd5_7, 2240, 144, 8, 22
	.member	_rsvd5_8, 2272, 144, 8, 22
	.member	_SPIRXINTA, 2304, 144, 8, 22
	.member	_SPITXINTA, 2336, 144, 8, 22
	.member	_SPIRXINTB, 2368, 144, 8, 22
	.member	_SPITXINTB, 2400, 144, 8, 22
	.member	_SPIRXINTC, 2432, 144, 8, 22
	.member	_SPITXINTC, 2464, 144, 8, 22
	.member	_SPIRXINTD, 2496, 144, 8, 22
	.member	_SPITXINTD, 2528, 144, 8, 22
	.member	_rsvd7_1, 2560, 144, 8, 22
	.member	_rsvd7_2, 2592, 144, 8, 22
	.member	_rsvd7_3, 2624, 144, 8, 22
	.member	_rsvd7_4, 2656, 144, 8, 22
	.member	_rsvd7_5, 2688, 144, 8, 22
	.member	_rsvd7_6, 2720, 144, 8, 22
	.member	_rsvd7_7, 2752, 144, 8, 22
	.member	_rsvd7_8, 2784, 144, 8, 22
	.member	_I2CINT1A, 2816, 144, 8, 22
	.member	_I2CINT2A, 2848, 144, 8, 22
	.member	_rsvd8_3, 2880, 144, 8, 22
	.member	_rsvd8_4, 2912, 144, 8, 22
	.member	_rsvd8_5, 2944, 144, 8, 22
	.member	_rsvd8_6, 2976, 144, 8, 22
	.member	_rsvd8_7, 3008, 144, 8, 22
	.member	_rsvd8_8, 3040, 144, 8, 22
	.member	_SCIRXINTA, 3072, 144, 8, 22
	.member	_SCITXINTA, 3104, 144, 8, 22
	.member	_SCIRXINTB, 3136, 144, 8, 22
	.member	_SCITXINTB, 3168, 144, 8, 22
	.member	_ECAN0INTA, 3200, 144, 8, 22
	.member	_ECAN1INTA, 3232, 144, 8, 22
	.member	_ECAN0INTB, 3264, 144, 8, 22
	.member	_ECAN1INTB, 3296, 144, 8, 22
	.member	_rsvd10_1, 3328, 144, 8, 22
	.member	_rsvd10_2, 3360, 144, 8, 22
	.member	_rsvd10_3, 3392, 144, 8, 22
	.member	_rsvd10_4, 3424, 144, 8, 22
	.member	_rsvd10_5, 3456, 144, 8, 22
	.member	_rsvd10_6, 3488, 144, 8, 22
	.member	_rsvd10_7, 3520, 144, 8, 22
	.member	_rsvd10_8, 3552, 144, 8, 22
	.member	_rsvd11_1, 3584, 144, 8, 22
	.member	_rsvd11_2, 3616, 144, 8, 22
	.member	_rsvd11_3, 3648, 144, 8, 22
	.member	_rsvd11_4, 3680, 144, 8, 22
	.member	_rsvd11_5, 3712, 144, 8, 22
	.member	_rsvd11_6, 3744, 144, 8, 22
	.member	_rsvd11_7, 3776, 144, 8, 22
	.member	_rsvd11_8, 3808, 144, 8, 22
	.member	_rsvd12_1, 3840, 144, 8, 22
	.member	_rsvd12_2, 3872, 144, 8, 22
	.member	_rsvd12_3, 3904, 144, 8, 22
	.member	_rsvd12_4, 3936, 144, 8, 22
	.member	_rsvd12_5, 3968, 144, 8, 22
	.member	_rsvd12_6, 4000, 144, 8, 22
	.member	_rsvd12_7, 4032, 144, 8, 22
	.member	_rsvd12_8, 4064, 144, 8, 22
	.eos
	.stag	_SCICCR_BITS, 16
	.member	_SCICHAR, 0, 14, 18, 3
	.member	_ADDRIDLE_MODE, 3, 14, 18, 1
	.member	_LOOPBKENA, 4, 14, 18, 1
	.member	_PARITYENA, 5, 14, 18, 1
	.member	_PARITY, 6, 14, 18, 1
	.member	_STOPBITS, 7, 14, 18, 1
	.member	_rsvd1, 8, 14, 18, 8
	.eos
	.utag	_SCICCR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCICCR_BITS
	.eos
	.stag	_SCICTL1_BITS, 16
	.member	_RXENA, 0, 14, 18, 1
	.member	_TXENA, 1, 14, 18, 1
	.member	_SLEEP, 2, 14, 18, 1
	.member	_TXWAKE, 3, 14, 18, 1
	.member	_rsvd, 4, 14, 18, 1
	.member	_SWRESET, 5, 14, 18, 1
	.member	_RXERRINTENA, 6, 14, 18, 1
	.member	_rsvd1, 7, 14, 18, 9
	.eos
	.utag	_SCICTL1_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCICTL1_BITS
	.eos
	.stag	_SCICTL2_BITS, 16
	.member	_TXINTENA, 0, 14, 18, 1
	.member	_RXBKINTENA, 1, 14, 18, 1
	.member	_rsvd, 2, 14, 18, 4
	.member	_TXEMPTY, 6, 14, 18, 1
	.member	_TXRDY, 7, 14, 18, 1
	.member	_rsvd1, 8, 14, 18, 8
	.eos
	.utag	_SCICTL2_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCICTL2_BITS
	.eos
	.stag	_SCIRXST_BITS, 16
	.member	_rsvd, 0, 14, 18, 1
	.member	_RXWAKE, 1, 14, 18, 1
	.member	_PE, 2, 14, 18, 1
	.member	_OE, 3, 14, 18, 1
	.member	_FE, 4, 14, 18, 1
	.member	_BRKDT, 5, 14, 18, 1
	.member	_RXRDY, 6, 14, 18, 1
	.member	_RXERROR, 7, 14, 18, 1
	.eos
	.utag	_SCIRXST_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCIRXST_BITS
	.eos
	.stag	_SCIRXBUF_BITS, 16
	.member	_RXDT, 0, 14, 18, 8
	.member	_rsvd, 8, 14, 18, 6
	.member	_SCIFFPE, 14, 14, 18, 1
	.member	_SCIFFFE, 15, 14, 18, 1
	.eos
	.utag	_SCIRXBUF_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCIRXBUF_BITS
	.eos
	.stag	_SCIFFTX_BITS, 16
	.member	_TXFFIL, 0, 14, 18, 5
	.member	_TXFFIENA, 5, 14, 18, 1
	.member	_TXFFINTCLR, 6, 14, 18, 1
	.member	_TXFFINT, 7, 14, 18, 1
	.member	_TXFFST, 8, 14, 18, 5
	.member	_TXFIFOXRESET, 13, 14, 18, 1
	.member	_SCIFFENA, 14, 14, 18, 1
	.member	_SCIRST, 15, 14, 18, 1
	.eos
	.utag	_SCIFFTX_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCIFFTX_BITS
	.eos
	.stag	_SCIFFRX_BITS, 16
	.member	_RXFFIL, 0, 14, 18, 5
	.member	_RXFFIENA, 5, 14, 18, 1
	.member	_RXFFINTCLR, 6, 14, 18, 1
	.member	_RXFFINT, 7, 14, 18, 1
	.member	_RXFFST, 8, 14, 18, 5
	.member	_RXFIFORESET, 13, 14, 18, 1
	.member	_RXFFOVRCLR, 14, 14, 18, 1
	.member	_RXFFOVF, 15, 14, 18, 1
	.eos
	.utag	_SCIFFRX_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCIFFRX_BITS
	.eos
	.stag	_SCIFFCT_BITS, 16
	.member	_FFTXDLY, 0, 14, 18, 8
	.member	_rsvd, 8, 14, 18, 5
	.member	_CDC, 13, 14, 18, 1
	.member	_ABDCLR, 14, 14, 18, 1
	.member	_ABD, 15, 14, 18, 1
	.eos
	.utag	_SCIFFCT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCIFFCT_BITS
	.eos
	.stag	_SCIPRI_BITS, 16
	.member	_rsvd, 0, 14, 18, 3
	.member	_FREE, 3, 14, 18, 1
	.member	_SOFT, 4, 14, 18, 1
	.member	_rsvd1, 5, 14, 18, 3
	.eos
	.utag	_SCIPRI_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SCIPRI_BITS
	.eos
	.stag	_SCI_REGS, 256
	.member	_SCICCR, 0, 9, 8, 16, _SCICCR_REG
	.member	_SCICTL1, 16, 9, 8, 16, _SCICTL1_REG
	.member	_SCIHBAUD, 32, 14, 8, 16
	.member	_SCILBAUD, 48, 14, 8, 16
	.member	_SCICTL2, 64, 9, 8, 16, _SCICTL2_REG
	.member	_SCIRXST, 80, 9, 8, 16, _SCIRXST_REG
	.member	_SCIRXEMU, 96, 14, 8, 16
	.member	_SCIRXBUF, 112, 9, 8, 16, _SCIRXBUF_REG
	.member	_rsvd1, 128, 14, 8, 16
	.member	_SCITXBUF, 144, 14, 8, 16
	.member	_SCIFFTX, 160, 9, 8, 16, _SCIFFTX_REG
	.member	_SCIFFRX, 176, 9, 8, 16, _SCIFFRX_REG
	.member	_SCIFFCT, 192, 9, 8, 16, _SCIFFCT_REG
	.member	_rsvd2, 208, 14, 8, 16
	.member	_rsvd3, 224, 14, 8, 16
	.member	_SCIPRI, 240, 9, 8, 16, _SCIPRI_REG
	.eos
	.stag	_SPICCR_BITS, 16
	.member	_SPICHAR, 0, 14, 18, 4
	.member	_SPILBK, 4, 14, 18, 1
	.member	_rsvd1, 5, 14, 18, 1
	.member	_CLKPOLARITY, 6, 14, 18, 1
	.member	_SPISWRESET, 7, 14, 18, 1
	.member	_rsvd2, 8, 14, 18, 8
	.eos
	.utag	_SPICCR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SPICCR_BITS
	.eos
	.stag	_SPICTL_BITS, 16
	.member	_SPIINTENA, 0, 14, 18, 1
	.member	_TALK, 1, 14, 18, 1
	.member	_MASTER_SLAVE, 2, 14, 18, 1
	.member	_CLK_PHASE, 3, 14, 18, 1
	.member	_OVERRUNINTENA, 4, 14, 18, 1
	.member	_rsvd, 5, 14, 18, 11
	.eos
	.utag	_SPICTL_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SPICTL_BITS
	.eos
	.stag	_SPISTS_BITS, 16
	.member	_rsvd1, 0, 14, 18, 5
	.member	_BUFFULL_FLAG, 5, 14, 18, 1
	.member	_INT_FLAG, 6, 14, 18, 1
	.member	_OVERRUN_FLAG, 7, 14, 18, 1
	.member	_rsvd2, 8, 14, 18, 8
	.eos
	.utag	_SPISTS_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SPISTS_BITS
	.eos
	.stag	_SPIFFTX_BITS, 16
	.member	_TXFFIL, 0, 14, 18, 5
	.member	_TXFFIENA, 5, 14, 18, 1
	.member	_TXFFINTCLR, 6, 14, 18, 1
	.member	_TXFFINT, 7, 14, 18, 1
	.member	_TXFFST, 8, 14, 18, 5
	.member	_TXFIFO, 13, 14, 18, 1
	.member	_SPIFFENA, 14, 14, 18, 1
	.member	_SPIRST, 15, 14, 18, 1
	.eos
	.utag	_SPIFFTX_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SPIFFTX_BITS
	.eos
	.stag	_SPIFFRX_BITS, 16
	.member	_RXFFIL, 0, 14, 18, 5
	.member	_RXFFIENA, 5, 14, 18, 1
	.member	_RXFFINTCLR, 6, 14, 18, 1
	.member	_RXFFINT, 7, 14, 18, 1
	.member	_RXFFST, 8, 14, 18, 5
	.member	_RXFIFORESET, 13, 14, 18, 1
	.member	_RXFFOVFCLR, 14, 14, 18, 1
	.member	_RXFFOVF, 15, 14, 18, 1
	.eos
	.utag	_SPIFFRX_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SPIFFRX_BITS
	.eos
	.stag	_SPIFFCT_BITS, 16
	.member	_TXDLY, 0, 14, 18, 8
	.member	_rsvd, 8, 14, 18, 8
	.eos
	.utag	_SPIFFCT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SPIFFCT_BITS
	.eos
	.stag	_SPIPRI_BITS, 16
	.member	_rsvd1, 0, 14, 18, 4
	.member	_FREE, 4, 14, 18, 1
	.member	_SOFT, 5, 14, 18, 1
	.member	_PRIORITY, 6, 14, 18, 1
	.member	_rsvd2, 7, 14, 18, 9
	.eos
	.utag	_SPIPRI_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _SPIPRI_BITS
	.eos
	.stag	_SPI_REGS, 256
	.member	_SPICCR, 0, 9, 8, 16, _SPICCR_REG
	.member	_SPICTL, 16, 9, 8, 16, _SPICTL_REG
	.member	_SPISTS, 32, 9, 8, 16, _SPISTS_REG
	.member	_rsvd1, 48, 14, 8, 16
	.member	_SPIBRR, 64, 14, 8, 16
	.member	_rsvd2, 80, 14, 8, 16
	.member	_SPIRXEMU, 96, 14, 8, 16
	.member	_SPIRXBUF, 112, 14, 8, 16
	.member	_SPITXBUF, 128, 14, 8, 16
	.member	_SPIDAT, 144, 14, 8, 16
	.member	_SPIFFTX, 160, 9, 8, 16, _SPIFFTX_REG
	.member	_SPIFFRX, 176, 9, 8, 16, _SPIFFRX_REG
	.member	_SPIFFCT, 192, 9, 8, 16, _SPIFFCT_REG
	.member	_rsvd3, 208, 62, 8, 32, , 2
	.member	_SPIPRI, 240, 9, 8, 16, _SPIPRI_REG
	.eos
	.stag	_XCLK_BITS, 16
	.member	_XCLKOUTDIV, 0, 14, 18, 2
	.member	_XCLKOUTDAT, 2, 14, 18, 1
	.member	_X1DAT, 3, 14, 18, 1
	.member	_XCLKINDAT, 4, 14, 18, 1
	.member	_rsvd1, 5, 14, 18, 3
	.member	_X1CNT, 8, 14, 18, 4
	.member	_XCLKINCNT, 12, 14, 18, 4
	.eos
	.utag	_XCLK_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _XCLK_BITS
	.eos
	.stag	_PLLSTS_BITS, 16
	.member	_PLLLOCKS, 0, 14, 18, 1
	.member	_rsvd1, 1, 14, 18, 1
	.member	_PLLOFF, 2, 14, 18, 1
	.member	_MCLKSTS, 3, 14, 18, 1
	.member	_MCLKCLR, 4, 14, 18, 1
	.member	_OSCOFF, 5, 14, 18, 1
	.member	_MCLKOFF, 6, 14, 18, 1
	.member	_rsvd2, 7, 14, 18, 9
	.eos
	.utag	_PLLSTS_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PLLSTS_BITS
	.eos
	.stag	_HISPCP_BITS, 16
	.member	_HSPCLK, 0, 14, 18, 3
	.member	_rsvd1, 3, 14, 18, 13
	.eos
	.utag	_HISPCP_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _HISPCP_BITS
	.eos
	.stag	_LOSPCP_BITS, 16
	.member	_LSPCLK, 0, 14, 18, 3
	.member	_rsvd1, 3, 14, 18, 13
	.eos
	.utag	_LOSPCP_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _LOSPCP_BITS
	.eos
	.stag	_PCLKCR0_BITS, 16
	.member	_rsvd1, 0, 14, 18, 2
	.member	_TBCLKSYNC, 2, 14, 18, 1
	.member	_ADCENCLK, 3, 14, 18, 1
	.member	_I2CAENCLK, 4, 14, 18, 1
	.member	_rsvd2, 5, 14, 18, 1
	.member	_SPICENCLK, 6, 14, 18, 1
	.member	_SPIDENCLK, 7, 14, 18, 1
	.member	_SPIAENCLK, 8, 14, 18, 1
	.member	_SPIBENCLK, 9, 14, 18, 1
	.member	_SCIAENCLK, 10, 14, 18, 1
	.member	_SCIBENCLK, 11, 14, 18, 1
	.member	_rsvd3, 12, 14, 18, 2
	.member	_ECANAENCLK, 14, 14, 18, 1
	.member	_ECANBENCLK, 15, 14, 18, 1
	.eos
	.utag	_PCLKCR0_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PCLKCR0_BITS
	.eos
	.stag	_PCLKCR1_BITS, 16
	.member	_EPWM1ENCLK, 0, 14, 18, 1
	.member	_EPWM2ENCLK, 1, 14, 18, 1
	.member	_EPWM3ENCLK, 2, 14, 18, 1
	.member	_EPWM4ENCLK, 3, 14, 18, 1
	.member	_EPWM5ENCLK, 4, 14, 18, 1
	.member	_EPWM6ENCLK, 5, 14, 18, 1
	.member	_rsvd1, 6, 14, 18, 2
	.member	_ECAP1ENCLK, 8, 14, 18, 1
	.member	_ECAP2ENCLK, 9, 14, 18, 1
	.member	_ECAP3ENCLK, 10, 14, 18, 1
	.member	_ECAP4ENCLK, 11, 14, 18, 1
	.member	_rsvd2, 12, 14, 18, 2
	.member	_EQEP1ENCLK, 14, 14, 18, 1
	.member	_EQEP2ENCLK, 15, 14, 18, 1
	.eos
	.utag	_PCLKCR1_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PCLKCR1_BITS
	.eos
	.stag	_LPMCR0_BITS, 16
	.member	_LPM, 0, 14, 18, 2
	.member	_QUALSTDBY, 2, 14, 18, 6
	.member	_rsvd1, 8, 14, 18, 7
	.member	_WDINTE, 15, 14, 18, 1
	.eos
	.utag	_LPMCR0_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _LPMCR0_BITS
	.eos
	.stag	_PLLCR_BITS, 16
	.member	_DIV, 0, 14, 18, 4
	.member	_rsvd1, 4, 14, 18, 12
	.eos
	.utag	_PLLCR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _PLLCR_BITS
	.eos
	.stag	_SYS_CTRL_REGS, 512
	.member	_XCLK, 0, 9, 8, 16, _XCLK_REG
	.member	_PLLSTS, 16, 9, 8, 16, _PLLSTS_REG
	.member	_rsvd1, 32, 62, 8, 128, , 8
	.member	_HISPCP, 160, 9, 8, 16, _HISPCP_REG
	.member	_LOSPCP, 176, 9, 8, 16, _LOSPCP_REG
	.member	_PCLKCR0, 192, 9, 8, 16, _PCLKCR0_REG
	.member	_PCLKCR1, 208, 9, 8, 16, _PCLKCR1_REG
	.member	_LPMCR0, 224, 9, 8, 16, _LPMCR0_REG
	.member	_rsvd2, 240, 14, 8, 16
	.member	_rsvd3, 256, 14, 8, 16
	.member	_PLLCR, 272, 9, 8, 16, _PLLCR_REG
	.member	_SCSR, 288, 14, 8, 16
	.member	_WDCNTR, 304, 14, 8, 16
	.member	_rsvd4, 320, 14, 8, 16
	.member	_WDKEY, 336, 14, 8, 16
	.member	_rsvd5, 352, 62, 8, 48, , 3
	.member	_WDCR, 400, 14, 8, 16
	.member	_rsvd6, 416, 62, 8, 96, , 6
	.eos
	.stag	_FOPT_BITS, 16
	.member	_ENPIPE, 0, 14, 18, 1
	.member	_rsvd, 1, 14, 18, 15
	.eos
	.utag	_FOPT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _FOPT_BITS
	.eos
	.stag	_FPWR_BITS, 16
	.member	_PWR, 0, 14, 18, 2
	.member	_rsvd, 2, 14, 18, 14
	.eos
	.utag	_FPWR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _FPWR_BITS
	.eos
	.stag	_FSTATUS_BITS, 16
	.member	_PWRS, 0, 14, 18, 2
	.member	_STDBYWAITS, 2, 14, 18, 1
	.member	_ACTIVEWAITS, 3, 14, 18, 1
	.member	_rsvd1, 4, 14, 18, 4
	.member	_V3STAT, 8, 14, 18, 1
	.member	_rsvd2, 9, 14, 18, 7
	.eos
	.utag	_FSTATUS_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _FSTATUS_BITS
	.eos
	.stag	_FSTDBYWAIT_BITS, 16
	.member	_STDBYWAIT, 0, 14, 18, 8
	.member	_rsvd, 8, 14, 18, 8
	.eos
	.utag	_FSTDBYWAIT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _FSTDBYWAIT_BITS
	.eos
	.stag	_FACTIVEWAIT_BITS, 16
	.member	_ACTIVEWAIT, 0, 14, 18, 8
	.member	_rsvd, 8, 14, 18, 8
	.eos
	.utag	_FACTIVEWAIT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _FACTIVEWAIT_BITS
	.eos
	.stag	_FBANKWAIT_BITS, 16
	.member	_RANDWAIT, 0, 14, 18, 4
	.member	_rsvd1, 4, 14, 18, 4
	.member	_PAGEWAIT, 8, 14, 18, 4
	.member	_rsvd2, 12, 14, 18, 4
	.eos
	.utag	_FBANKWAIT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _FBANKWAIT_BITS
	.eos
	.stag	_FOTPWAIT_BITS, 16
	.member	_OTPWAIT, 0, 14, 18, 5
	.member	_rsvd, 5, 14, 18, 11
	.eos
	.utag	_FOTPWAIT_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _FOTPWAIT_BITS
	.eos
	.stag	_FLASH_REGS, 128
	.member	_FOPT, 0, 9, 8, 16, _FOPT_REG
	.member	_rsvd1, 16, 14, 8, 16
	.member	_FPWR, 32, 9, 8, 16, _FPWR_REG
	.member	_FSTATUS, 48, 9, 8, 16, _FSTATUS_REG
	.member	_FSTDBYWAIT, 64, 9, 8, 16, _FSTDBYWAIT_REG
	.member	_FACTIVEWAIT, 80, 9, 8, 16, _FACTIVEWAIT_REG
	.member	_FBANKWAIT, 96, 9, 8, 16, _FBANKWAIT_REG
	.member	_FOTPWAIT, 112, 9, 8, 16, _FOTPWAIT_REG
	.eos
	.stag	_XINTCR_BITS, 16
	.member	_ENABLE, 0, 14, 18, 1
	.member	_rsvd1, 1, 14, 18, 1
	.member	_POLARITY, 2, 14, 18, 2
	.member	_rsvd2, 4, 14, 18, 12
	.eos
	.utag	_XINTCR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _XINTCR_BITS
	.eos
	.stag	_XNMICR_BITS, 16
	.member	_ENABLE, 0, 14, 18, 1
	.member	_SELECT, 1, 14, 18, 1
	.member	_POLARITY, 2, 14, 18, 2
	.member	_rsvd2, 4, 14, 18, 12
	.eos
	.utag	_XNMICR_REG, 16
	.member	_all, 0, 14, 11, 16
	.member	_bit, 0, 8, 11, 16, _XNMICR_BITS
	.eos
	.stag	_XINTRUPT_REGS, 256
	.member	_XINT1CR, 0, 9, 8, 16, _XINTCR_REG
	.member	_XINT2CR, 16, 9, 8, 16, _XINTCR_REG
	.member	_rsvd1, 32, 62, 8, 80, , 5
	.member	_XNMICR, 112, 9, 8, 16, _XNMICR_REG
	.member	_XINT1CTR, 128, 14, 8, 16
	.member	_XINT2CTR, 144, 14, 8, 16
	.member	_rsvd, 160, 62, 8, 80, , 5
	.member	_XNMICTR, 240, 14, 8, 16
	.eos

DSP280x_GlobalV/1113835044  33    0     0       10612     `
// TI File $Revision: /main/1 $
// Checkin $Date: December 1, 2004   12:32:52 $
//###########################################################################
//
// FILE:	DSP280x_GlobalVariableDefs.c
//
// TITLE:	DSP280x Global Variables and Data Section Pragmas.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File

//---------------------------------------------------------------------------
// Define Global Peripheral Variables:
//
//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("AdcRegsFile") 
#else 
#pragma DATA_SECTION(AdcRegs,"AdcRegsFile");
#endif 
volatile struct ADC_REGS AdcRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("AdcMirrorFile") 
#else 
#pragma DATA_SECTION(AdcMirror,"AdcMirrorFile");
#endif 
volatile struct ADC_RESULT_MIRROR_REGS AdcMirror;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("CpuTimer0RegsFile") 
#else 
#pragma DATA_SECTION(CpuTimer0Regs,"CpuTimer0RegsFile");
#endif
volatile struct CPUTIMER_REGS CpuTimer0Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("CpuTimer1RegsFile") 
#else 
#pragma DATA_SECTION(CpuTimer1Regs,"CpuTimer1RegsFile");
#endif
volatile struct CPUTIMER_REGS CpuTimer1Regs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("CpuTimer2RegsFile") 
#else 
#pragma DATA_SECTION(CpuTimer2Regs,"CpuTimer2RegsFile");
#endif
volatile struct CPUTIMER_REGS CpuTimer2Regs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("CsmPwlFile") 
#else
#pragma DATA_SECTION(CsmPwl,"CsmPwlFile");
#endif
volatile struct CSM_PWL CsmPwl;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("CsmRegsFile") 
#else
#pragma DATA_SECTION(CsmRegs,"CsmRegsFile");
#endif
volatile struct CSM_REGS CsmRegs;



//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("DevEmuRegsFile") 
#else
#pragma DATA_SECTION(DevEmuRegs,"DevEmuRegsFile");
#endif
volatile struct DEV_EMU_REGS DevEmuRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanaRegsFile") 
#else 
#pragma DATA_SECTION(ECanaRegs,"ECanaRegsFile");
#endif
volatile struct ECAN_REGS ECanaRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanaMboxesFile") 
#else 
#pragma DATA_SECTION(ECanaMboxes,"ECanaMboxesFile");
#endif
volatile struct ECAN_MBOXES ECanaMboxes;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanaLAMRegsFile") 
#else 
#pragma DATA_SECTION(ECanaLAMRegs,"ECanaLAMRegsFile");
#endif
volatile struct LAM_REGS ECanaLAMRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanaMOTSRegsFile") 
#else 
#pragma DATA_SECTION(ECanaMOTSRegs,"ECanaMOTSRegsFile");
#endif
volatile struct MOTS_REGS ECanaMOTSRegs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanaMOTORegsFile") 
#else 
#pragma DATA_SECTION(ECanaMOTORegs,"ECanaMOTORegsFile");
#endif
volatile struct MOTO_REGS ECanaMOTORegs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanbRegsFile") 
#else 
#pragma DATA_SECTION(ECanbRegs,"ECanbRegsFile");
#endif
volatile struct ECAN_REGS ECanbRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanbMboxesFile") 
#else 
#pragma DATA_SECTION(ECanbMboxes,"ECanbMboxesFile");
#endif
volatile struct ECAN_MBOXES ECanbMboxes;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanbLAMRegsFile") 
#else 
#pragma DATA_SECTION(ECanbLAMRegs,"ECanbLAMRegsFile");
#endif
volatile struct LAM_REGS ECanbLAMRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanbMOTSRegsFile") 
#else 
#pragma DATA_SECTION(ECanbMOTSRegs,"ECanbMOTSRegsFile");
#endif
volatile struct MOTS_REGS ECanbMOTSRegs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECanbMOTORegsFile") 
#else 
#pragma DATA_SECTION(ECanbMOTORegs,"ECanbMOTORegsFile");
#endif
volatile struct MOTO_REGS ECanbMOTORegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EPwm1RegsFile") 
#else 
#pragma DATA_SECTION(EPwm1Regs,"EPwm1RegsFile");
#endif
volatile struct EPWM_REGS EPwm1Regs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EPwm2RegsFile") 
#else 
#pragma DATA_SECTION(EPwm2Regs,"EPwm2RegsFile");
#endif
volatile struct EPWM_REGS EPwm2Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EPwm3RegsFile") 
#else 
#pragma DATA_SECTION(EPwm3Regs,"EPwm3RegsFile");
#endif
volatile struct EPWM_REGS EPwm3Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EPwm4RegsFile") 
#else 
#pragma DATA_SECTION(EPwm4Regs,"EPwm4RegsFile");
#endif
volatile struct EPWM_REGS EPwm4Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EPwm5RegsFile") 
#else 
#pragma DATA_SECTION(EPwm5Regs,"EPwm5RegsFile");
#endif
volatile struct EPWM_REGS EPwm5Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EPwm6RegsFile") 
#else 
#pragma DATA_SECTION(EPwm6Regs,"EPwm6RegsFile");
#endif
volatile struct EPWM_REGS EPwm6Regs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECap1RegsFile") 
#else 
#pragma DATA_SECTION(ECap1Regs,"ECap1RegsFile");
#endif
volatile struct ECAP_REGS ECap1Regs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECap2RegsFile") 
#else 
#pragma DATA_SECTION(ECap2Regs,"ECap2RegsFile");
#endif
volatile struct ECAP_REGS ECap2Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECap3RegsFile") 
#else 
#pragma DATA_SECTION(ECap3Regs,"ECap3RegsFile");
#endif
volatile struct ECAP_REGS ECap3Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ECap4RegsFile") 
#else 
#pragma DATA_SECTION(ECap4Regs,"ECap4RegsFile");
#endif
volatile struct ECAP_REGS ECap4Regs;


//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EQep1RegsFile") 
#else 
#pragma DATA_SECTION(EQep1Regs,"EQep1RegsFile");
#endif
volatile struct EQEP_REGS EQep1Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("EQep2RegsFile") 
#else 
#pragma DATA_SECTION(EQep2Regs,"EQep2RegsFile");
#endif
volatile struct EQEP_REGS EQep2Regs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("GpioCtrlRegsFile") 
#else 
#pragma DATA_SECTION(GpioCtrlRegs,"GpioCtrlRegsFile");
#endif
volatile struct GPIO_CTRL_REGS GpioCtrlRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("GpioDataRegsFile") 
#else 
#pragma DATA_SECTION(GpioDataRegs,"GpioDataRegsFile");
#endif
volatile struct GPIO_DATA_REGS GpioDataRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("GpioIntRegsFile") 
#else 
#pragma DATA_SECTION(GpioIntRegs,"GpioIntRegsFile");
#endif
volatile struct GPIO_INT_REGS GpioIntRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("I2caRegsFile") 
#else 
#pragma DATA_SECTION(I2caRegs,"I2caRegsFile");
#endif
volatile struct I2C_REGS I2caRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("PieCtrlRegsFile") 
#else
#pragma DATA_SECTION(PieCtrlRegs,"PieCtrlRegsFile");
#endif
volatile struct PIE_CTRL_REGS PieCtrlRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("PieVectTableFile") 
#else
#pragma DATA_SECTION(PieVectTable,"PieVectTableFile");
#endif
struct PIE_VECT_TABLE PieVectTable;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("SciaRegsFile") 
#else
#pragma DATA_SECTION(SciaRegs,"SciaRegsFile");
#endif
volatile struct SCI_REGS SciaRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("ScibRegsFile") 
#else
#pragma DATA_SECTION(ScibRegs,"ScibRegsFile");
#endif
volatile struct SCI_REGS ScibRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("SpiaRegsFile") 
#else
#pragma DATA_SECTION(SpiaRegs,"SpiaRegsFile");
#endif
volatile struct SPI_REGS SpiaRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("SpibRegsFile") 
#else
#pragma DATA_SECTION(SpibRegs,"SpibRegsFile");
#endif
volatile struct SPI_REGS SpibRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("SpicRegsFile") 
#else
#pragma DATA_SECTION(SpicRegs,"SpicRegsFile");
#endif
volatile struct SPI_REGS SpicRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("SpidRegsFile") 
#else
#pragma DATA_SECTION(SpidRegs,"SpidRegsFile");
#endif
volatile struct SPI_REGS SpidRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("SysCtrlRegsFile") 
#else
#pragma DATA_SECTION(SysCtrlRegs,"SysCtrlRegsFile");
#endif
volatile struct SYS_CTRL_REGS SysCtrlRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("FlashRegsFile") 
#else
#pragma DATA_SECTION(FlashRegs,"FlashRegsFile");
#endif
volatile struct FLASH_REGS FlashRegs;

//----------------------------------------
#ifdef __cplusplus 
#pragma DATA_SECTION("XIntruptRegsFile") 
#else
#pragma DATA_SECTION(XIntruptRegs,"XIntruptRegsFile");
#endif
volatile struct XINTRUPT_REGS XIntruptRegs;



//===========================================================================
// End of file.
//===========================================================================









DSP280x_CodeSta/1113835036  63    0     0       3242      `
;// TI File $Revision: /main/1 $
;// Checkin $Date: December 1, 2004   11:11:32 $
;//###########################################################################
;//
;// FILE:  DSP280x_CodeStartBranch.asm	
;//
;// TITLE: Branch for redirecting code execution after boot. 
;//
;// For these examples, code_start is the first code that is executed after
;// exiting the boot ROM code. 
;//
;// The codestart section in the linker cmd file is used to physically place
;// this code at the correct memory location.  This section should be placed 
;// at the location the BOOT ROM will re-direct the code to.  For example, 
;// for boot to FLASH this code will be located at 0x3f7ff6. 
;//
;// In addition, the example DSP280x projects are setup such that the codegen
;// entry point is also set to the code_start label.  This is done by linker 
;// option -e in the project build options.  When the debugger loads the code,
;// it will automatically set the PC to the "entry point" address indicated by
;// the -e linker option.  In this case the debugger is simply assigning the PC, 
;// it is not the same as a full reset of the device. 
;// 
;// The compiler may warn that the entry point for the project is other then
;//  _c_init00.  _c_init00 is the C environment setup and is run before 
;// main() is entered. The code_start code will re-direct the execution 
;// to _c_init00 and thus there is no worry and this warning can be ignored. 
;// 
;//###########################################################################
;// $TI Release: DSP280x V1.10 $
;// $Release Date: April 18, 2005 $
;//###########################################################################


***********************************************************************

WD_DISABLE	.set	1		;set to 1 to disable WD, else set to 0

    .ref _c_int00
    .global code_start

***********************************************************************
* Function: codestart section
*
* Description: Branch to code starting point
***********************************************************************

    .sect "codestart"

code_start:
    .if WD_DISABLE == 1
        LB wd_disable       ;Branch to watchdog disable code
    .else
        LB _c_int00         ;Branch to start of boot.asm in RTS library
    .endif

;end codestart section


***********************************************************************
* Function: wd_disable
*
* Description: Disables the watchdog timer
***********************************************************************
    .if WD_DISABLE == 1

    .text
wd_disable:
    SETC OBJMODE        ;Set OBJMODE for 28x object code
    EALLOW              ;Enable EALLOW protected register access
    MOVZ DP, #7029h>>6  ;Set data page for WDCR register
    MOV @7029h, #0068h  ;Set WDDIS bit in WDCR to disable WD
    EDIS                ;Disable EALLOW protected register access
    LB _c_int00         ;Branch to start of boot.asm in RTS library

    .endif

;end wd_disable



	.end
	
;//===========================================================================
;// End of file.
;//===========================================================================DSP280x_CSMPass/1113835036  92    0     0       2555      `
;// TI File $Revision: /main/1 $
;// Checkin $Date: December 1, 2004   11:11:36 $
;//###########################################################################
;//
;// FILE:	DSP280x_CSMPasswords.asm
;//
;// TITLE:	DSP280x Code Security Module Passwords.
;// 
;// DESCRIPTION:
;//
;//         This file is used to specify password values to
;//         program into the CSM password locations in Flash
;//         at 0x3F7FF8 - 0x3F7FFF.
;//
;//         In addition, the reserved locations 0x3F7F80 - 0X3f7ff5 are 
;//         all programmed to 0x0000
;//
;//###########################################################################
;//
;// Original source based on D.A.
;// 
;// $TI Release: DSP280x V1.10 $
;// $Release Date: April 18, 2005 $
;//###########################################################################

; The "csmpasswords" section contains the actual CSM passwords that will be
; linked and programmed into to the CSM password locations (PWL) in flash.  
; These passwords must be known in order to unlock the CSM module. 
; All 0xFFFF's (erased) is the default value for the password locations (PWL).

; It is recommended that all passwords be left as 0xFFFF during code
; development.  Passwords of 0xFFFF do not activate code security and dummy 
; reads of the CSM PWL registers is all that is required to unlock the CSM.  
; When code development is complete, modify the passwords to activate the
; code security module.

      .sect "csmpasswds"

      .int	0xFFFF		;PWL0 (LSW of 128-bit password)
      .int	0xFFFF		;PWL1
      .int	0xFFFF		;PWL2
      .int	0xFFFF		;PWL3
      .int	0xFFFF		;PWL4
      .int	0xFFFF		;PWL5
      .int	0xFFFF		;PWL6
      .int	0xFFFF		;PWL7 (MSW of 128-bit password)
	
;----------------------------------------------------------------------

; For code security operation, all addresses between 0x3F7F80 and
; 0X3f7ff5 cannot be used as program code or data.  These locations
; must be programmed to 0x0000 when the code security password locations
; (PWL) are programmed.  If security is not a concern, then these addresses
; can be used for code or data.  

; The section "csm_rsvd" can be used to program these locations to 0x0000.

        .sect "csm_rsvd"
        .loop (3F7FF5h - 3F7F80h + 1)
              .int 0x0000
        .endloop

;//===========================================================================
;// End of file.
;//===========================================================================

      

DSP280x_DBGIER./1113835036  118   0     0       856       `
;// TI File $Revision: /main/1 $
;// Checkin $Date: December 1, 2004   11:11:38 $
;//###########################################################################
;//
;// FILE:  DSP280x_DBGIER.asm
;//
;// TITLE: Set the DBGIER register
;//
;// DESCRIPTION:
;//  
;//  Function to set the DBGIER register (for realtime emulation).
;//  Function Prototype: void SetDBGIER(Uint16)
;//  Useage: SetDBGIER(value);
;//  Input Parameters: Uint16 value = value to put in DBGIER register. 
;//  Return Value: none          
;//
;//###########################################################################
;// $TI Release: DSP280x V1.10 $
;// $Release Date: April 18, 2005 $
;//###########################################################################	
		.global _SetDBGIER
		.text
		
_SetDBGIER:
		MOV 	*SP++,AL
		POP 	DBGIER
		LRETR
		DSP280x_DisInt./1113835036  138   0     0       1726      `
;// TI File $Revision: /main/1 $
;// Checkin $Date: December 1, 2004   11:11:44 $
;//###########################################################################
;//
;// FILE:  DSP280x_DisInt.asm	
;//
;// TITLE: Disable and Restore INTM and DBGM
;// 
;// Function Prototypes:
;//
;//      Uint16 DSP28x_DisableInt();
;// and  void DSP28x_RestoreInt(Uint16 Stat0);
;//
;// Usage:
;//
;//      DSP28x_DisableInt() sets both the INTM and DBGM
;//      bits to disable maskable interrupts.  Before doing
;//      this, the current value of ST1 is stored on the stack
;//      so that the values can be restored later.  The value
;//      of ST1 before the masks are set is returned to the
;//      user in AL.  This is then used to restore their state
;//      via the DSP28x_RestoreInt(Uint16 ST1) function.
;//
;// Example
;//
;//   Uint16 StatusReg1    
;//   StatusReg1 = DSP28x_DisableInt();
;//
;//   ... May also want to disable INTM here
;// 
;//   ... code here
;//
;//   DSP28x_RestoreInt(StatusReg1);
;//
;//   ... Restore INTM enable
;//
;//###########################################################################
;// $TI Release: DSP280x V1.10 $
;// $Release Date: April 18, 2005 $
;//###########################################################################




   .def _DSP28x_DisableInt
   .def _DSP28x_RestoreInt


_DSP28x_DisableInt:
    PUSH  ST1
    SETC  INTM,DBGM
    MOV   AL, *--SP
    LRETR

_DSP28x_RestoreInt:
    MOV   *SP++, AL
    POP   ST1
    LRETR


;//===========================================================================
;// End of file.
;//===========================================================================

   DSP280x_usDelay/1113835038  158   0     0       2641      `
;// TI File $Revision: /main/1 $
;// Checkin $Date: December 1, 2004   11:12:13 $
;//###########################################################################
;//
;// FILE:  DSP280x_usDelay.asm
;//
;// TITLE: Simple delay function
;//
;// DESCRIPTION:
;//  
;// This is a simple delay function that can be used to insert a specified
;// delay into code.  
;// 
;// This function is only accurate if executed from internal zero-waitstate
;// SARAM. If it is executed from waitstate memory then the delay will be
;// longer then specified. 
;// 
;// To use this function:
;//
;//  1 - update the CPU clock speed in the DSP280x_Examples.h
;//    file. For example:
;//    #define CPU_CLOCK_SPEED 10.0000L // for a 100MHz CPU clock speed
;//
;//  2 - Call this function by using the DELAY_US(A) macro
;//    that is defined in the DSP28_Device.h file.  This macro
;//    will convert the number of microseconds specified
;//    into a loop count for use with this function.  
;//    This count will be based on the CPU frequency you specify.
;//
;//  3 - For the most accurate delay 
;//    - Execute this function in 0 waitstate RAM.  
;//    - Disable interrupts before calling the function
;//      If you do not disable interrupts, then think of
;//      this as an "at least" delay function as the actual
;//      delay may be longer. 
;//
;//  The C assembly call from the DELAY_US(time) macro will
;//  look as follows: 
;//
;//  extern void Delay(long LoopCount);                
;//
;//        MOV   AL,#LowLoopCount
;//        MOV   AH,#HighLoopCount
;//        LCR   _Delay
;//
;//  Or as follows (if count is less then 16-bits):
;//
;//        MOV   ACC,#LoopCount
;//        LCR   _Delay
;//
;//
;//###########################################################################
;// $TI Release: DSP280x V1.10 $
;// $Release Date: April 18, 2005 $
;//###########################################################################	

       .def _DSP28x_usDelay
       .sect "ramfuncs"

        .global  __DSP28x_usDelay
_DSP28x_usDelay:
        SUB    ACC,#1
        BF     _DSP28x_usDelay,GEQ    ;; Loop if ACC >= 0
        LRETR 

;There is a 9/10 cycle overhead and each loop
;takes five cycles. The LoopCount is given by
;the following formula:
;  DELAY_CPU_CYCLES = 9 + 5*LoopCount
; LoopCount = (DELAY_CPU_CYCLES - 9) / 5
; The macro DELAY_US(A) performs this calculation for you
;
;//===========================================================================
;// End of file.
;//===========================================================================

DSP280x_Adc.c/  1113835036  0     0     0       1892      `
// TI File $Revision: /main/1 $
// Checkin $Date: December 1, 2004   11:11:30 $
//###########################################################################
//
// FILE:	DSP280x_Adc.c
//
// TITLE:	DSP280x ADC Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

#define ADC_usDELAY  5000L

//---------------------------------------------------------------------------
// InitAdc: 
//---------------------------------------------------------------------------
// This function initializes ADC to a known state.
//
// PLEASE NOTE, ADC INIT IS DIFFERENT ON 281x vs 280x DEVICES!!!
//
void InitAdc(void)
{
    extern void DSP28x_usDelay(Uint32 Count);

    // To powerup the ADC the ADCENCLK bit should be set first to enable
    // clocks, followed by powering up the bandgap, reference circuitry, and ADC core.
    // Before the first conversion is performed a 5ms delay must be observed 
	// after power up to give all analog circuits time to power up and settle

    // Please note that for the delay function below to operate correctly the 
	// CPU_CLOCK_SPEED define statement in the DSP280x_Examples.h file must 
	// contain the correct CPU clock period in nanoseconds. 

    AdcRegs.ADCTRL3.all = 0x00E0;  // Power up bandgap/reference/ADC circuits
    DELAY_US(ADC_usDELAY);         // Delay before converting ADC channels
}	

//===========================================================================
// End of file.
//===========================================================================
DSP280x_CpuTime/1113835036  179   0     0       4427      `
// TI File $Revision: /main/1 $
// Checkin $Date: December 1, 2004   11:11:34 $
//###########################################################################
//
// FILE:	DSP280x_CpuTimers.c
//
// TITLE:	CPU 32-bit Timers Initialization & Support Functions.
//
// NOTES:   CpuTimer1 and CpuTimer2 are reserved for use with DSP BIOS and
//          other realtime operating systems.  
//
//          Do not use these two timers in your application if you ever plan
//          on integrating DSP-BIOS or another realtime OS. 
//
//          For this reason, the code to manipulate these two timers is
//          commented out and not used in these examples.
//           
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // Headerfile Include File
#include "DSP280x_Examples.h"   // Examples Include File

struct CPUTIMER_VARS CpuTimer0;

// CpuTimer 1 and CpuTimer2 are reserved for DSP BIOS & other RTOS
//struct CPUTIMER_VARS CpuTimer1;
//struct CPUTIMER_VARS CpuTimer2;

//---------------------------------------------------------------------------
// InitCpuTimers: 
//---------------------------------------------------------------------------
// This function initializes all three CPU timers to a known state.
//
void InitCpuTimers(void)
{
    // CPU Timer 0
	// Initialize address pointers to respective timer registers:
	CpuTimer0.RegsAddr = &CpuTimer0Regs;
	// Initialize timer period to maximum:	
	CpuTimer0Regs.PRD.all  = 0xFFFFFFFF;
	// Initialize pre-scale counter to divide by 1 (SYSCLKOUT):	
	CpuTimer0Regs.TPR.all  = 0;
	CpuTimer0Regs.TPRH.all = 0;
	// Make sure timer is stopped:
	CpuTimer0Regs.TCR.bit.TSS = 1;
	// Reload all counter register with period value:
	CpuTimer0Regs.TCR.bit.TRB = 1;
	// Reset interrupt counters:
	CpuTimer0.InterruptCount = 0;	             	
	
	
// CpuTimer 1 and CpuTimer2 are reserved for DSP BIOS & other RTOS
// Do not use these two timers if you ever plan on integrating 
// DSP-BIOS or another realtime OS. 
//
// For this reason, the code to manipulate these two timers is
// commented out and not used in these examples.

    // Initialize address pointers to respective timer registers:
//	CpuTimer1.RegsAddr = &CpuTimer1Regs;
//	CpuTimer2.RegsAddr = &CpuTimer2Regs;
	// Initialize timer period to maximum:
//	CpuTimer1Regs.PRD.all  = 0xFFFFFFFF;
//	CpuTimer2Regs.PRD.all  = 0xFFFFFFFF;
	// Make sure timers are stopped:
//	CpuTimer1Regs.TCR.bit.TSS = 1;             
//	CpuTimer2Regs.TCR.bit.TSS = 1;             
	// Reload all counter register with period value:
//	CpuTimer1Regs.TCR.bit.TRB = 1;             
//	CpuTimer2Regs.TCR.bit.TRB = 1;             
	// Reset interrupt counters:
//	CpuTimer1.InterruptCount = 0;
//	CpuTimer2.InterruptCount = 0;

}	
	
//---------------------------------------------------------------------------
// ConfigCpuTimer: 
//---------------------------------------------------------------------------
// This function initializes the selected timer to the period specified
// by the "Freq" and "Period" parameters. The "Freq" is entered as "MHz"
// and the period in "uSeconds". The timer is held in the stopped state
// after configuration.
//
void ConfigCpuTimer(struct CPUTIMER_VARS *Timer, float Freq, float Period)
{
	Uint32 	temp;
	
	// Initialize timer period:	
	Timer->CPUFreqInMHz = Freq;
	Timer->PeriodInUSec = Period;
	temp = (long) (Freq * Period);
	Timer->RegsAddr->PRD.all = temp;

	// Set pre-scale counter to divide by 1 (SYSCLKOUT):	
	Timer->RegsAddr->TPR.all  = 0;
	Timer->RegsAddr->TPRH.all  = 0;
	
	// Initialize timer control register:
	Timer->RegsAddr->TCR.bit.TSS = 1;      // 1 = Stop timer, 0 = Start/Restart Timer 
	Timer->RegsAddr->TCR.bit.TRB = 1;      // 1 = reload timer
	Timer->RegsAddr->TCR.bit.SOFT = 1;
	Timer->RegsAddr->TCR.bit.FREE = 1;     // Timer Free Run
	Timer->RegsAddr->TCR.bit.TIE = 1;      // 0 = Disable/ 1 = Enable Timer Interrupt
	
	// Reset interrupt counter:
	Timer->InterruptCount = 0;
}

//===========================================================================
// End of file.
//===========================================================================

DSP280x_Default/1113835036  200   0     0       25452     `
// TI File $Revision: /main/2 $
// Checkin $Date: December 1, 2004   16:21:15 $
//###########################################################################
//
// FILE:	DSP280x_DefaultIsr.c
//
// TITLE:	DSP280x Device Default Interrupt Service Routines.
//
// This file contains shell ISR routines for the 280x PIE vector table.
// Typically these shell ISR routines can be used to populate the entire PIE 
// vector table during device debug.  In this manner if an interrupt is taken
// during firmware development, there will always be an ISR to catch it.  
//
// As develpment progresses, these ISR rotuines can be eliminated and replaced
// with the user's own ISR routines for each interrupt.  Since these shell ISRs
// include infinite loops they will typically not be included as-is in the final
// production firmware. 
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File


// Connected to INT13 of CPU (use MINT13 mask):
// Note CPU-Timer1 is reserved for TI use, however XINT13
// ISR can be used by the user. 
interrupt void INT13_ISR(void)     // INT13 or CPU-Timer1
{
  // Insert ISR Code here
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// Note CPU-Timer2 is reserved for TI use.
interrupt void INT14_ISR(void)     // CPU-Timer2
{
  // Insert ISR Code here
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void DATALOG_ISR(void)   // Datalogging interrupt
{
   // Insert ISR Code here
 
   // Next two lines for debug only to halt the processor here
   // Remove after inserting ISR Code
   asm ("      ESTOP0");
   for(;;);
}

interrupt void RTOSINT_ISR(void)   // RTOS interrupt
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void EMUINT_ISR(void)    // Emulation interrupt
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void NMI_ISR(void)       // Non-maskable interrupt
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void ILLEGAL_ISR(void)   // Illegal operation TRAP
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm("          ESTOP0");
  for(;;);

}


interrupt void USER1_ISR(void)     // User Defined trap 1
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

interrupt void USER2_ISR(void)     // User Defined trap 2
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);


}

interrupt void USER3_ISR(void)     // User Defined trap 3
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER4_ISR(void)     // User Defined trap 4
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER5_ISR(void)     // User Defined trap 5
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER6_ISR(void)     // User Defined trap 6
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER7_ISR(void)     // User Defined trap 7
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER8_ISR(void)     // User Defined trap 8
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER9_ISR(void)     // User Defined trap 9
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER10_ISR(void)    // User Defined trap 10
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER11_ISR(void)    // User Defined trap 11
{
  // Insert ISR Code here

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

interrupt void USER12_ISR(void)     // User Defined trap 12
{
 // Insert ISR Code here
 
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// -----------------------------------------------------------
// PIE Group 1 - MUXed into CPU INT1
// -----------------------------------------------------------

// INT1.1 
interrupt void SEQ1INT_ISR(void)   //SEQ1 ADC
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code

  asm ("      ESTOP0");
  for(;;);

}     

// INT1.2 
interrupt void SEQ2INT_ISR(void)  //SEQ2 ADC
{

  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  
  asm("	  ESTOP0");
  for(;;);
	
}
// INT1.3 - Reserved

// INT1.4
interrupt void  XINT1_ISR(void)
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}     

// INT1.5
interrupt void  XINT2_ISR(void)
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// INT1.6
interrupt void  ADCINT_ISR(void)     // ADC
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; 
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT1.7
interrupt void  TINT0_ISR(void)      // CPU-Timer 0
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; 
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}


// INT1.8
interrupt void  WAKEINT_ISR(void)    // WD, LOW Power
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; 
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}


// -----------------------------------------------------------
// PIE Group 2 - MUXed into CPU INT2
// -----------------------------------------------------------

// INT2.1
interrupt void EPWM1_TZINT_ISR(void)    // EPWM-1
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT2.2
interrupt void EPWM2_TZINT_ISR(void)    // EPWM-2
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT2.3
interrupt void EPWM3_TZINT_ISR(void)    // EPWM-3
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}


// INT2.4
interrupt void EPWM4_TZINT_ISR(void)    // EPWM-4
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}


// INT2.5
interrupt void EPWM5_TZINT_ISR(void)    // EPWM-5
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT2.6
interrupt void EPWM6_TZINT_ISR(void)   // EPWM-6
{
  // Insert ISR Code here

   
  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT2.7 - Reserved
// INT2.8 - Reserved

// -----------------------------------------------------------
// PIE Group 3 - MUXed into CPU INT3
// -----------------------------------------------------------
   
// INT 3.1         
interrupt void EPWM1_INT_ISR(void)     // EPWM-1
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT3.2
interrupt void EPWM2_INT_ISR(void)     // EPWM-2
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT3.3
interrupt void EPWM3_INT_ISR(void)    // EPWM-3
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT3.4
interrupt void EPWM4_INT_ISR(void)    // EPWM-4
{
  // Insert ISR Code here
  
  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;  

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT3.5
interrupt void EPWM5_INT_ISR(void)    // EPWM-5
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;  

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT3.6
interrupt void EPWM6_INT_ISR(void)    // EPWM-6
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT3.7 - Reserved
// INT3.8 - Reserved


// -----------------------------------------------------------
// PIE Group 4 - MUXed into CPU INT4
// -----------------------------------------------------------

// INT 4.1
interrupt void ECAP1_INT_ISR(void)    // ECAP-1
{
  // Insert ISR Code here
  
  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;  

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT4.2
interrupt void ECAP2_INT_ISR(void)    // ECAP-2
{
  // Insert ISR Code here
  
  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT4.3
interrupt void ECAP3_INT_ISR(void)    // ECAP-3
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT4.4
interrupt void ECAP4_INT_ISR(void)     // ECAP-4
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT4.5 - Reserved
// INT4.6 - Reserved
// INT4.7 - Reserved
// INT4.8 - Reserved

// -----------------------------------------------------------
// PIE Group 5 - MUXed into CPU INT5
// -----------------------------------------------------------

// INT 5.1
interrupt void EQEP1_INT_ISR(void)    // EQEP-1
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT5.2
interrupt void EQEP2_INT_ISR(void)    // EQEP-2
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;
 
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT5.3 - Reserved
// INT5.4 - Reserved
// INT5.5 - Reserved
// INT5.6 - Reserved
// INT5.7 - Reserved
// INT5.8 - Reserved

// -----------------------------------------------------------
// PIE Group 6 - MUXed into CPU INT6
// -----------------------------------------------------------

// INT6.1
interrupt void SPIRXINTA_ISR(void)    // SPI-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT6.2
interrupt void SPITXINTA_ISR(void)     // SPI-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT6.3 
interrupt void SPIRXINTB_ISR(void)     // SPI-B
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT6.4
interrupt void SPITXINTB_ISR(void)     // SPI-B
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT6.5
interrupt void SPIRXINTC_ISR(void)     // SPI-C
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT6.6
interrupt void SPITXINTC_ISR(void)     // SPI-C
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT6.7
interrupt void SPIRXINTD_ISR(void)     // SPI-D
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT6.8
interrupt void SPITXINTD_ISR(void)     // SPI-D
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}


// -----------------------------------------------------------
// PIE Group 7 - MUXed into CPU INT7
// -----------------------------------------------------------

// INT7.1 - Reserved
// INT7.2 - Reserved
// INT7.3 - Reserved
// INT7.4 - Reserved
// INT7.5 - Reserved
// INT7.6 - Reserved
// INT7.7 - Reserved
// INT7.8 - Reserved

// -----------------------------------------------------------
// PIE Group 8 - MUXed into CPU INT8
// -----------------------------------------------------------

// INT8.1
interrupt void I2CINT1A_ISR(void)     // I2C-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT8.2
interrupt void I2CINT2A_ISR(void)     // I2C-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);
}

// INT8.3 - Reserved
// INT8.4 - Reserved
// INT8.5 - Reserved
// INT8.6 - Reserved
// INT8.7 - Reserved
// INT8.8 - Reserved


// -----------------------------------------------------------
// PIE Group 9 - MUXed into CPU INT9
// -----------------------------------------------------------

// INT9.1
interrupt void SCIRXINTA_ISR(void)     // SCI-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// INT9.2
interrupt void SCITXINTA_ISR(void)     // SCI-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}


// INT9.3
interrupt void SCIRXINTB_ISR(void)     // SCI-B
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// INT9.4
interrupt void SCITXINTB_ISR(void)     // SCI-B
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// INT9.5
interrupt void ECAN0INTA_ISR(void)  // eCAN-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// INT9.6
interrupt void ECAN1INTA_ISR(void)  // eCAN-A
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// INT9.7
interrupt void ECAN0INTB_ISR(void)  // eCAN-B
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// INT9.8
interrupt void ECAN1INTB_ISR(void)  // eCAN-B
{
  // Insert ISR Code here

  // To receive more interrupts from this PIE group, acknowledge this interrupt 
  // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;

  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
  asm ("      ESTOP0");
  for(;;);

}

// -----------------------------------------------------------
// PIE Group 10 - MUXed into CPU INT10
// -----------------------------------------------------------

// INT10.1 - Reserved
// INT10.2 - Reserved
// INT10.3 - Reserved
// INT10.4 - Reserved
// INT10.5 - Reserved
// INT10.6 - Reserved
// INT10.7 - Reserved
// INT10.8 - Reserved


// -----------------------------------------------------------
// PIE Group 11 - MUXed into CPU INT11
// -----------------------------------------------------------

// INT11.1 - Reserved
// INT11.2 - Reserved
// INT11.3 - Reserved
// INT11.4 - Reserved
// INT11.5 - Reserved
// INT11.6 - Reserved
// INT11.7 - Reserved
// INT11.8 - Reserved

// -----------------------------------------------------------
// PIE Group 12 - MUXed into CPU INT12
// -----------------------------------------------------------

// INT12.1 - Reserved
// INT12.2 - Reserved
// INT12.3 - Reserved
// INT12.4 - Reserved
// INT12.5 - Reserved
// INT12.6 - Reserved
// INT12.7 - Reserved
// INT12.8 - Reserved

//---------------------------------------------------------------------------
// Catch All Default ISRs: 
//

interrupt void EMPTY_ISR(void)  // Empty ISR - only does a return.
{

}

interrupt void PIE_RESERVED(void)  // Reserved space.  For test.
{
  asm ("      ESTOP0");
  for(;;);
}

interrupt void rsvd_ISR(void)      // For test
{
  asm ("      ESTOP0");
  for(;;);
}

//===========================================================================
// End of file.
//===========================================================================

DSP280x_ECan.c/ 1113835036  0     0     0       14632     `
// TI File $Revision: /main/5 $
// Checkin $Date: January 11, 2005   13:56:29 $
//###########################################################################
//
// FILE:	DSP280x_ECan.c
//
// TITLE:	DSP280x Enhanced CAN Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP28 Headerfile Include File
#include "DSP280x_Examples.h"   // DSP28 Examples Include File


//---------------------------------------------------------------------------
// InitECan: 
//---------------------------------------------------------------------------
// This function initializes the eCAN module to a known state.
//
void InitECan(void)
{
   InitECana();
#if DSP28_2808
   InitECanb();
#endif // if DSP28_2808
}

void InitECana(void)		// Initialize eCAN-A module
{
/* Create a shadow register structure for the CAN control registers. This is
 needed, since, only 32-bit access is allowed to these registers. 16-bit access
 to these registers could potentially corrupt the register contents. This is
 especially true while writing to a bit (or group of bits) among bits 16 - 31 */

struct ECAN_REGS ECanaShadow;

	EALLOW;		// EALLOW enables access to protected bits

/* Configure eCAN RX and TX pins for eCAN transmissions using eCAN regs*/  
    
    ECanaRegs.CANTIOC.bit.TXFUNC = 1;
    ECanaRegs.CANRIOC.bit.RXFUNC = 1;  

/* Configure eCAN for HECC mode - (reqd to access mailboxes 16 thru 31) */
									// HECC mode also enables time-stamping feature
	
	ECanaShadow.CANMC.all = ECanaRegs.CANMC.all;
	ECanaShadow.CANMC.bit.SCB = 1;				
	ECanaRegs.CANMC.all = ECanaShadow.CANMC.all;
	
/* Initialize all bits of 'Master Control Field' to zero */
// Some bits of MSGCTRL register come up in an unknown state. For proper operation,
// all bits (including reserved bits) of MSGCTRL must be initialized to zero
 
    ECanaMboxes.MBOX0.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX1.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX2.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX3.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX4.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX5.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX6.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX7.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX8.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX9.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX10.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX11.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX12.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX13.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX14.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX15.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX16.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX17.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX18.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX19.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX20.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX21.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX22.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX23.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX24.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX25.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX26.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX27.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX28.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX29.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX30.MSGCTRL.all = 0x00000000;
    ECanaMboxes.MBOX31.MSGCTRL.all = 0x00000000;
    
// TAn, RMPn, GIFn bits are all zero upon reset and are cleared again
//	as a matter of precaution. 

	ECanaRegs.CANTA.all	= 0xFFFFFFFF;	/* Clear all TAn bits */      
	
	ECanaRegs.CANRMP.all = 0xFFFFFFFF;	/* Clear all RMPn bits */      
	
	ECanaRegs.CANGIF0.all = 0xFFFFFFFF;	/* Clear all interrupt flag bits */ 
	ECanaRegs.CANGIF1.all = 0xFFFFFFFF;

	
/* Configure bit timing parameters for eCANA*/
	ECanaShadow.CANMC.all = ECanaRegs.CANMC.all;
	ECanaShadow.CANMC.bit.CCR = 1 ;            // Set CCR = 1
    ECanaRegs.CANMC.all = ECanaShadow.CANMC.all;
    
    while(ECanaRegs.CANES.bit.CCE != 1 ) {}   // Wait for CCE bit to be set..
    
    ECanaShadow.CANBTC.all = 0;
    ECanaShadow.CANBTC.bit.BRPREG = 9;
    ECanaShadow.CANBTC.bit.TSEG2REG = 1;
    ECanaShadow.CANBTC.bit.TSEG1REG = 6; 
    ECanaShadow.CANBTC.bit.SAM = 1;
    ECanaRegs.CANBTC.all = ECanaShadow.CANBTC.all;
    
    ECanaShadow.CANMC.all = ECanaRegs.CANMC.all;
	ECanaShadow.CANMC.bit.CCR = 0 ;            // Set CCR = 0
    ECanaRegs.CANMC.all = ECanaShadow.CANMC.all;
    
    while(ECanaRegs.CANES.bit.CCE == !0 ) {}   // Wait for CCE bit to be cleared..

/* Disable all Mailboxes  */
 	ECanaRegs.CANME.all = 0;		// Required before writing the MSGIDs

    EDIS;
}	


#if DSP28_2808
void InitECanb(void)		// Initialize eCAN-B module
{
/* Create a shadow register structure for the CAN control registers. This is
 needed, since, only 32-bit access is allowed to these registers. 16-bit access
 to these registers could potentially corrupt the register contents. This is
 especially true while writing to a bit (or group of bits) among bits 16 - 31 */

struct ECAN_REGS ECanbShadow;

   EALLOW;		// EALLOW enables access to protected bits

/* Configure eCAN RX and TX pins for eCAN transmissions using eCAN regs*/  
    
    ECanbRegs.CANTIOC.bit.TXFUNC = 1;
    ECanbRegs.CANRIOC.bit.RXFUNC = 1;   

/* Configure eCAN for HECC mode - (reqd to access mailboxes 16 thru 31) */

	ECanbShadow.CANMC.all = ECanbRegs.CANMC.all;
	ECanbShadow.CANMC.bit.SCB = 1;				
	ECanbRegs.CANMC.all = ECanbShadow.CANMC.all;
	
/* Initialize all bits of 'Master Control Field' to zero */
// Some bits of MSGCTRL register come up in an unknown state. For proper operation,
// all bits (including reserved bits) of MSGCTRL must be initialized to zero
 
    ECanbMboxes.MBOX0.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX1.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX2.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX3.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX4.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX5.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX6.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX7.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX8.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX9.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX10.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX11.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX12.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX13.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX14.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX15.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX16.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX17.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX18.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX19.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX20.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX21.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX22.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX23.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX24.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX25.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX26.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX27.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX28.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX29.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX30.MSGCTRL.all = 0x00000000;
    ECanbMboxes.MBOX31.MSGCTRL.all = 0x00000000;

// TAn, RMPn, GIFn bits are all zero upon reset and are cleared again
//	as a matter of precaution. 

	ECanbRegs.CANTA.all	= 0xFFFFFFFF;	/* Clear all TAn bits */ 	

	ECanbRegs.CANRMP.all = 0xFFFFFFFF;	/* Clear all RMPn bits */ 
	
	ECanbRegs.CANGIF0.all = 0xFFFFFFFF;	/* Clear all interrupt flag bits */
	ECanbRegs.CANGIF1.all = 0xFFFFFFFF;

	
/* Configure bit timing parameters for eCANB*/

	ECanbShadow.CANMC.all = ECanbRegs.CANMC.all;
	ECanbShadow.CANMC.bit.CCR = 1 ;            // Set CCR = 1
    ECanbRegs.CANMC.all = ECanbShadow.CANMC.all;
    
    while(ECanbRegs.CANES.bit.CCE != 1 ) {}   // Wait for CCE bit to be set..
    
    ECanbShadow.CANBTC.all = 0;
    ECanbShadow.CANBTC.bit.BRPREG = 9;
    ECanbShadow.CANBTC.bit.TSEG2REG = 1;
    ECanbShadow.CANBTC.bit.TSEG1REG = 6; 
    ECanbShadow.CANBTC.bit.SAM = 1;
    ECanbRegs.CANBTC.all = ECanbShadow.CANBTC.all;
    
    ECanbShadow.CANMC.all = ECanbRegs.CANMC.all;
	ECanbShadow.CANMC.bit.CCR = 0 ;            // Set CCR = 0
    ECanbRegs.CANMC.all = ECanbShadow.CANMC.all;
    
    while(ECanbRegs.CANES.bit.CCE == !0 ) {}   // Wait for CCE bit to be cleared..
	
/* Disable all Mailboxes  */
 	ECanbRegs.CANME.all = 0;		// Required before writing the MSGIDs

    EDIS;
}
#endif // if DSP28_2808


//---------------------------------------------------------------------------
// Example: InitECanGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as eCAN pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 
// Caution: 
// Only one GPIO pin should be enabled for CANTXA/B operation.
// Only one GPIO pin shoudl be enabled for CANRXA/B operation. 
// Comment out other unwanted lines.


void InitECanGpio(void)
{
   InitECanaGpio();
#if DSP28_2808
   InitECanbGpio();
#endif // if DSP28_2808
}

void InitECanaGpio(void)
{
   EALLOW;

/* Enable internal pull-up for the selected CAN pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

	GpioCtrlRegs.GPAPUD.bit.GPIO30 = 0;	    // Enable pull-up for GPIO30 (CANRXA)
	GpioCtrlRegs.GPAPUD.bit.GPIO31 = 0;	    // Enable pull-up for GPIO31 (CANTXA)

/* Set qualification for selected CAN pins to asynch only */
// Inputs are synchronized to SYSCLKOUT by default.  
// This will select asynch (no qualification) for the selected pins.

    GpioCtrlRegs.GPAQSEL2.bit.GPIO30 = 3;   // Asynch qual for GPIO30 (CANRXA)   

/* Configure eCAN-A pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eCAN functional pins.

	GpioCtrlRegs.GPAMUX2.bit.GPIO30 = 1;	// Configure GPIO30 for CANTXA operation
	GpioCtrlRegs.GPAMUX2.bit.GPIO31 = 1;	// Configure GPIO31 for CANRXA operation
	

    EDIS;
}

#if DSP28_2808
void InitECanbGpio(void)
{
   EALLOW;
	
/* Enable internal pull-up for the selected CAN pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

	GpioCtrlRegs.GPAPUD.bit.GPIO8 = 0;	  // Enable pull-up for GPIO8  (CANTXB) 
//  GpioCtrlRegs.GPAPUD.bit.GPIO12 = 0;   // Enable pull-up for GPIO12 (CANTXB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO16 = 0;   // Enable pull-up for GPIO16 (CANTXB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO20 = 0;   // Enable pull-up for GPIO20 (CANTXB)

	GpioCtrlRegs.GPAPUD.bit.GPIO10 = 0;	  // Enable pull-up for GPIO10 (CANRXB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO13 = 0;   // Enable pull-up for GPIO13 (CANRXB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO17 = 0;   // Enable pull-up for GPIO17 (CANRXB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO21 = 0;   // Enable pull-up for GPIO21 (CANRXB)

/* Set qualification for selected CAN pins to asynch only */
// Inputs are synchronized to SYSCLKOUT by default.  
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAQSEL1.bit.GPIO10 = 3; // Asynch qual for GPIO10 (CANRXB)   
//  GpioCtrlRegs.GPAQSEL1.bit.GPIO13 = 3; // Asynch qual for GPIO13 (CANRXB)   
//  GpioCtrlRegs.GPAQSEL2.bit.GPIO17 = 3; // Asynch qual for GPIO17 (CANRXB)   
//  GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 3; // Asynch qual for GPIO21 (CANRXB)   

/* Configure eCAN-B pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eCAN functional pins.

	GpioCtrlRegs.GPAMUX1.bit.GPIO8 = 2;   // Configure GPIO8 for CANTXB operation
//  GpioCtrlRegs.GPAMUX1.bit.GPIO12 = 2;  // Configure GPIO12 for CANTXB operation
//  GpioCtrlRegs.GPAMUX2.bit.GPIO16 = 2;  // Configure GPIO16 for CANTXB operation
//  GpioCtrlRegs.GPAMUX2.bit.GPIO20 = 3;  // Configure GPIO20 for CANTXB operation

	GpioCtrlRegs.GPAMUX1.bit.GPIO10 = 2;  // Configure GPIO10 for CANRXB operation
//  GpioCtrlRegs.GPAMUX1.bit.GPIO13 = 2;  // Configure GPIO13 for CANRXB operation
//  GpioCtrlRegs.GPAMUX2.bit.GPIO17 = 2;  // Configure GPIO17 for CANRXB operation
//  GpioCtrlRegs.GPAMUX2.bit.GPIO21 = 3;  // Configure GPIO21 for CANRXB operation
    
    EDIS;
}
#endif // if DSP28_2808

	
/***************************************************/
/* Bit configuration parameters for 100 MHz SYSCLKOUT*/ 
/***************************************************/
/*

The table below shows how BRP field must be changed to achieve different bit
rates with a BT of 10, for a 80% SP:
---------------------------------------------------
BT = 10, TSEG1 = 6, TSEG2 = 1, Sampling Point = 80% 
---------------------------------------------------
1   Mbps : BRP+1 = 10 	: CAN clock = 10 MHz
500 kbps : BRP+1 = 20 	: CAN clock = 5 MHz 
250 kbps : BRP+1 = 40 	: CAN clock = 2.5 MHz 
125 kbps : BRP+1 = 80 	: CAN clock = 1.25 MHz 
100 kbps : BRP+1 = 100 	: CAN clock = 1 MHz
50  kbps : BRP+1 = 200 	: CAN clock = 0.5 MHz

The table below shows how to achieve different sampling points with a BT of 25:
-------------------------------------------------------------
Achieving desired SP by changing TSEG1 & TSEG2 with BT = 25  
-------------------------------------------------------------

TSEG1 = 18, TSEG2 = 4, SP = 80% 
TSEG1 = 17, TSEG2 = 5, SP = 76% 
TSEG1 = 16, TSEG2 = 6, SP = 72% 
TSEG1 = 15, TSEG2 = 7, SP = 68% 
TSEG1 = 14, TSEG2 = 8, SP = 64% 

The table below shows how BRP field must be changed to achieve different bit
rates with a BT of 25, for the sampling points shown above: 

1   Mbps : BRP+1 = 4 
500 kbps : BRP+1 = 8 
250 kbps : BRP+1 = 16 
125 kbps : BRP+1 = 32 
100 kbps : BRP+1 = 40
50  kbps : BRP+1 = 80

*/

//===========================================================================
// End of file.
//===========================================================================

DSP280x_ECap.c/ 1113835036  0     0     0       5992      `
// TI File $Revision: /main/3 $
// Checkin $Date: December 2, 2004   14:44:36 $
//###########################################################################
//
// FILE:   DSP280x_ECap.c
//
// TITLE:  DSP280x eCAP Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitECap: 
//---------------------------------------------------------------------------
// This function initializes the eCAP(s) to a known state.
//
void InitECap(void)
{
   // Initialize eCAP1/2/3

   //tbd...
 
}

//---------------------------------------------------------------------------
// Example: InitECapGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as ECAP pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 
// Caution: 
// For each eCAP peripheral
// Only one GPIO pin should be enabled for ECAP operation. 
// Comment out other unwanted lines.

void InitECapGpio()
{

   InitECap1Gpio();
   InitECap2Gpio();
#if DSP28_2808 || DSP28_2806     
   InitECap3Gpio();
   InitECap4Gpio();
#endif // endif DSP28_2808 || DSP28_2806     
}

void InitECap1Gpio(void)
{
   EALLOW;
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

// GpioCtrlRegs.GPAPUD.bit.GPIO5 = 0;      // Enable pull-up on GPIO5 (CAP1)
   GpioCtrlRegs.GPAPUD.bit.GPIO24 = 0;     // Enable pull-up on GPIO24 (CAP1)

// Inputs are synchronized to SYSCLKOUT by default.  
// Comment out other unwanted lines.

// GpioCtrlRegs.GPAQSEL1.bit.GPIO5 = 0;    // Synch to SYSCLKOUT GPIO5 (CAP1)
   GpioCtrlRegs.GPAQSEL2.bit.GPIO24 = 0;   // Synch to SYSCLKOUT GPIO24 (CAP1)

/* Configure eCAP-1 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eCAP1 functional pins.
// Comment out other unwanted lines.

// GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 3;     // Configure GPIO5 as CAP1
   GpioCtrlRegs.GPAMUX2.bit.GPIO24 = 1;    // Configure GPIO24 as CAP1
    
    EDIS;
}

void InitECap2Gpio(void)
{
   EALLOW;
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAPUD.bit.GPIO7 = 0;     // Enable pull-up on GPIO7 (CAP2)
// GpioCtrlRegs.GPAPUD.bit.GPIO25 = 0;    // Enable pull-up on GPIO25 (CAP2)

// Inputs are synchronized to SYSCLKOUT by default.  
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAQSEL1.bit.GPIO7 = 0;    // Synch to SYSCLKOUT GPIO7 (CAP2)
// GpioCtrlRegs.GPAQSEL2.bit.GPIO25 = 0;   // Synch to SYSCLKOUT GPIO25 (CAP2)

/* Configure eCAP-2 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eCAP2 functional pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 3;    // Configure GPIO7 as CAP2
// GpioCtrlRegs.GPAMUX2.bit.GPIO25 = 1;   // Configure GPIO25 as CAP2
    
    EDIS;
}

#if DSP28_2808 || DSP28_2806
void InitECap3Gpio(void)
{
   EALLOW;

/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAPUD.bit.GPIO9 = 0;      // Enable pull-up on GPIO9 (CAP3)
// GpioCtrlRegs.GPAPUD.bit.GPIO26 = 0;     // Enable pull-up on GPIO26 (CAP3)

// Inputs are synchronized to SYSCLKOUT by default.  
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAQSEL1.bit.GPIO9 = 0;    // Synch to SYSCLKOUT GPIO9 (CAP3)
// GpioCtrlRegs.GPAQSEL2.bit.GPIO26 = 0;   // Synch to SYSCLKOUT GPIO26 (CAP3)

/* Configure eCAP-3 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eCAP3 functional pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 3;     // Configure GPIO9 as CAP3
// GpioCtrlRegs.GPAMUX2.bit.GPIO26 = 1;    // Configure GPIO26 as CAP3
    
    EDIS;
}
#endif // endif DSP28_2808 || DSP28_2806   


#if DSP28_2808 || DSP28_2806
void InitECap4Gpio(void)
{
   EALLOW;

/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAPUD.bit.GPIO11 = 0;   // Enable pull-up on GPIO11 (CAP4)
// GpioCtrlRegs.GPAPUD.bit.GPIO27 = 0;   // Enable pull-up on GPIO27 (CAP4)

// Inputs are synchronized to SYSCLKOUT by default.  
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAQSEL1.bit.GPIO11 = 0; // Synch to SYSCLKOUT GPIO11 (CAP4)
// GpioCtrlRegs.GPAQSEL2.bit.GPIO27 = 0; // Synch to SYSCLKOUT GPIO27 (CAP4)

/* Configure eCAP-4 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eCAP4 functional pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAMUX1.bit.GPIO11 = 3;  // Configure GPIO11 as CAP4
// GpioCtrlRegs.GPAMUX2.bit.GPIO27 = 1;  // Configure GPIO27 as CAP4
    
    EDIS;
}   
#endif // endif DSP28_2808 || DSP28_2806  



//===========================================================================
// End of file.
//===========================================================================
DSP280x_EPwm.c/ 1113835036  0     0     0       11322     `
// TI File $Revision: /main/3 $
// Checkin $Date: December 2, 2004   14:54:39 $
//###########################################################################
//
// FILE:   DSP280x_EPwm.c
//
// TITLE:  DSP280x ePWM Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitEPwm: 
//---------------------------------------------------------------------------
// This function initializes the ePWM(s) to a known state.
//
void InitEPwm(void)
{
   // Initialize ePWM1/2/3/4/5/6

   //tbd...
 
}

//---------------------------------------------------------------------------
// Example: InitEPwmGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as ePWM pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 

void InitEPwmGpio(void)
{
   InitEPwm1Gpio();
   InitEPwm2Gpio();
   InitEPwm3Gpio();
#if DSP28_2808 || DSP28_2806     
   InitEPwm4Gpio();
   InitEPwm5Gpio();
   InitEPwm6Gpio();
#endif // endif DSP28_2808 || DSP28_2806     
}

void InitEPwm1Gpio(void)
{
   EALLOW;
   
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO0 = 0;    // Enable pull-up on GPIO0 (EPWM1A)
    GpioCtrlRegs.GPAPUD.bit.GPIO1 = 0;    // Enable pull-up on GPIO1 (EPWM1B)   
   
/* Configure ePWM-1 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be ePWM1 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1;   // Configure GPIO0 as EPWM1A
    GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1;   // Configure GPIO1 as EPWM1B
   
    EDIS;
}

void InitEPwm2Gpio(void)
{
   EALLOW;
	
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO2 = 0;    // Enable pull-up on GPIO2 (EPWM2A)
    GpioCtrlRegs.GPAPUD.bit.GPIO3 = 0;    // Enable pull-up on GPIO3 (EPWM3B)

/* Configure ePWM-2 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be ePWM2 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1;   // Configure GPIO2 as EPWM2A
    GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1;   // Configure GPIO3 as EPWM2B
   
    EDIS;
}

void InitEPwm3Gpio(void)
{
   EALLOW;
   
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO4 = 0;    // Enable pull-up on GPIO4 (EPWM3A)
    GpioCtrlRegs.GPAPUD.bit.GPIO5 = 0;    // Enable pull-up on GPIO5 (EPWM3B)
       
/* Configure ePWM-3 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be ePWM3 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 1;   // Configure GPIO4 as EPWM3A
    GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 1;   // Configure GPIO5 as EPWM3B
	
    EDIS;
}


#if DSP28_2808 || DSP28_2806
void InitEPwm4Gpio(void)
{
   EALLOW;
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO6 = 0;    // Enable pull-up on GPIO6 (EPWM4A)
    GpioCtrlRegs.GPAPUD.bit.GPIO7 = 0;    // Enable pull-up on GPIO7 (EPWM4B)

/* Configure ePWM-4 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be ePWM4 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1;   // Configure GPIO6 as EPWM4A
    GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1;   // Configure GPIO7 as EPWM4B
	
    EDIS;
}
#endif // endif DSP28_2808 || DSP28_2806   


#if DSP28_2808 || DSP28_2806
void InitEPwm5Gpio(void)
{
   EALLOW;
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO8 = 0;    // Enable pull-up on GPIO8 (EPWM5A)
    GpioCtrlRegs.GPAPUD.bit.GPIO9 = 0;    // Enable pull-up on GPIO9 (EPWM5B)

/* Configure ePWM-5 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be ePWM5 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO8 = 1;   // Configure GPIO8 as EPWM5A
    GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 1;   // Configure GPIO9 as EPWM5B
	
    EDIS;
}
#endif // endif DSP28_2808 || DSP28_2806  


#if DSP28_2808 || DSP28_2806
void InitEPwm6Gpio(void)
{
   EALLOW;

/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO10 = 0;    // Enable pull-up on GPIO10 (EPWM6A)
    GpioCtrlRegs.GPAPUD.bit.GPIO11 = 0;    // Enable pull-up on GPIO11 (EPWM6B)

/* Configure ePWM-6 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be ePWM6 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO10 = 1;   // Configure GPIO10 as EPWM6A
    GpioCtrlRegs.GPAMUX1.bit.GPIO11 = 1;   // Configure GPIO11 as EPWM6B
	
    EDIS;
}
#endif // endif DSP28_2808 || DSP28_2806  

//---------------------------------------------------------------------------
// Example: InitEPwmSyncGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as ePWM Synch pins
//

void InitEPwmSyncGpio(void)
{

   EALLOW;

/* Configure EPWMSYNCI  */
   
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAPUD.bit.GPIO6 = 0;    // Enable pull-up on GPIO6 (EPWMSYNCI)
// GpioCtrlRegs.GPBPUD.bit.GPIO32 = 0;   // Enable pull-up on GPIO32 (EPWMSYNCI)    

/* Set qualification for selected pins to asynch only */
// This will select synch to SYSCLKOUT for the selected pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAQSEL1.bit.GPIO6 = 0;   // Synch to SYSCLKOUT GPIO6 (EPWMSYNCI)
// GpioCtrlRegs.GPBQSEL1.bit.GPIO32 = 0;  // Synch to SYSCLKOUT GPIO32 (EPWMSYNCI)    

/* Configure EPwmSync pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be EPwmSync functional pins.
// Comment out other unwanted lines.   

   GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 2;    // Enable pull-up on GPIO6 (EPWMSYNCI)
// GpioCtrlRegs.GPBMUX1.bit.GPIO32 = 2;   // Enable pull-up on GPIO32 (EPWMSYNCI)    



/* Configure EPWMSYNC0  */

/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

// GpioCtrlRegs.GPAPUD.bit.GPIO6 = 0;    // Enable pull-up on GPIO6 (EPWMSYNC0)
   GpioCtrlRegs.GPBPUD.bit.GPIO33 = 0;   // Enable pull-up on GPIO33 (EPWMSYNC0)    

// GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 3;    // Enable pull-up on GPIO6 (EPWMSYNC0)
   GpioCtrlRegs.GPBMUX1.bit.GPIO33 = 2;   // Enable pull-up on GPIO33 (EPWMSYNC0)    

}



//---------------------------------------------------------------------------
// Example: InitTzGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as Trip Zone (TZ) pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 

void InitTzGpio(void)
{
   EALLOW;
   
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.
   GpioCtrlRegs.GPAPUD.bit.GPIO12 = 0;    // Enable pull-up on GPIO12 (TZ1)
   GpioCtrlRegs.GPAPUD.bit.GPIO13 = 0;    // Enable pull-up on GPIO13 (TZ2)
   GpioCtrlRegs.GPAPUD.bit.GPIO14 = 0;    // Enable pull-up on GPIO14 (TZ3)
   GpioCtrlRegs.GPAPUD.bit.GPIO15 = 0;    // Enable pull-up on GPIO15 (TZ4)

   GpioCtrlRegs.GPAPUD.bit.GPIO16 = 0;    // Enable pull-up on GPIO16 (TZ5)
// GpioCtrlRegs.GPAPUD.bit.GPIO28 = 0;    // Enable pull-up on GPIO28 (TZ5)

   GpioCtrlRegs.GPAPUD.bit.GPIO17 = 0;    // Enable pull-up on GPIO17 (TZ6) 
// GpioCtrlRegs.GPAPUD.bit.GPIO29 = 0;    // Enable pull-up on GPIO29 (TZ6)  
   
/* Set qualification for selected pins to asynch only */
// Inputs are synchronized to SYSCLKOUT by default.  
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

   GpioCtrlRegs.GPAQSEL1.bit.GPIO12 = 3;  // Asynch input GPIO12 (TZ1)
   GpioCtrlRegs.GPAQSEL1.bit.GPIO13 = 3;  // Asynch input GPIO13 (TZ2)
   GpioCtrlRegs.GPAQSEL1.bit.GPIO14 = 3;  // Asynch input GPIO14 (TZ3)
   GpioCtrlRegs.GPAQSEL1.bit.GPIO15 = 3;  // Asynch input GPIO15 (TZ4)

   GpioCtrlRegs.GPAQSEL2.bit.GPIO16 = 3;  // Asynch input GPIO16 (TZ5)
// GpioCtrlRegs.GPAQSEL2.bit.GPIO28 = 3;  // Asynch input GPIO28 (TZ5)

   GpioCtrlRegs.GPAQSEL2.bit.GPIO17 = 3;  // Asynch input GPIO17 (TZ6) 
// GpioCtrlRegs.GPAQSEL2.bit.GPIO29 = 3;  // Asynch input GPIO29 (TZ6)  

   
/* Configure TZ pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be TZ functional pins.
// Comment out other unwanted lines.   
   GpioCtrlRegs.GPAMUX1.bit.GPIO12 = 1;  // Configure GPIO12 as TZ1
   GpioCtrlRegs.GPAMUX1.bit.GPIO13 = 1;  // Configure GPIO13 as TZ2
   GpioCtrlRegs.GPAMUX1.bit.GPIO14 = 1;  // Configure GPIO14 as TZ3
   GpioCtrlRegs.GPAMUX1.bit.GPIO15 = 1;  // Configure GPIO15 as TZ4

   GpioCtrlRegs.GPAMUX2.bit.GPIO16 = 3;  // Configure GPIO16 as TZ5
// GpioCtrlRegs.GPAMUX2.bit.GPIO28 = 3;  // Configure GPIO28 as TZ5

   GpioCtrlRegs.GPAMUX2.bit.GPIO17 = 3;  // Configure GPIO17 as TZ6               
// GpioCtrlRegs.GPAMUX2.bit.GPIO29 = 3;  // Configure GPIO29 as TZ6  

   EDIS;
}



//===========================================================================
// End of file.
//===========================================================================
DSP280x_EQep.c/ 1113835038  0     0     0       5169      `
// TI File $Revision: /main/2 $
// Checkin $Date: December 2, 2004   11:43:13 $
//###########################################################################
//
// FILE:   DSP280x_EQep.c
//
// TITLE:  DSP280x eQEP Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitEQep: 
//---------------------------------------------------------------------------
// This function initializes the eQEP(s) to a known state.
//
void InitEQep(void)
{
   // Initialize eQEP1/2

   //tbd...
 
}

//---------------------------------------------------------------------------
// Example: InitEQepGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as eQEP pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 
// Caution: 
// For each eQEP peripheral
// Only one GPIO pin should be enabled for EQEPxA operation. 
// Only one GPIO pin should be enabled for EQEPxB operation. 
// Only one GPIO pin should be enabled for EQEPxS operation. 
// Only one GPIO pin should be enabled for EQEPxI operation.
// Comment out other unwanted lines.

void InitEQepGpio()
{
   InitEQep1Gpio();
#if DSP28_2808 || DSP28_2806     
   InitEQep2Gpio();
#endif // endif DSP28_2808 || DSP28_2806     
}

void InitEQep1Gpio(void)
{
   EALLOW;
	
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO20 = 0;   // Enable pull-up on GPIO20 (EQEP1A)
    GpioCtrlRegs.GPAPUD.bit.GPIO21 = 0;   // Enable pull-up on GPIO21 (EQEP1B)
    GpioCtrlRegs.GPAPUD.bit.GPIO22 = 0;   // Enable pull-up on GPIO22 (EQEP1S)
    GpioCtrlRegs.GPAPUD.bit.GPIO23 = 0;   // Enable pull-up on GPIO23 (EQEP1I)


// Inputs are synchronized to SYSCLKOUT by default.  
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAQSEL2.bit.GPIO20 = 0;   // Sync to SYSCLKOUT GPIO20 (EQEP1A)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 0;   // Sync to SYSCLKOUT GPIO21 (EQEP1B)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO22 = 0;   // Sync to SYSCLKOUT GPIO22 (EQEP1S)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO23 = 0;   // Sync to SYSCLKOUT GPIO23 (EQEP1I)

/* Configure eQEP-1 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eQEP1 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX2.bit.GPIO20 = 1;   // Configure GPIO20 as EQEP1A
    GpioCtrlRegs.GPAMUX2.bit.GPIO21 = 1;   // Configure GPIO21 as EQEP1B
    GpioCtrlRegs.GPAMUX2.bit.GPIO22 = 1;   // Configure GPIO22 as EQEP1S
    GpioCtrlRegs.GPAMUX2.bit.GPIO23 = 1;   // Configure GPIO23 as EQEP1I


    EDIS;
}



#if DSP28_2808 || DSP28_2806
void InitEQep2Gpio(void)
{
   EALLOW;
	
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user. 
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO24 = 0;    // Enable pull-up on GPIO24 (EQEP2A)
    GpioCtrlRegs.GPAPUD.bit.GPIO25 = 0;    // Enable pull-up on GPIO25 (EQEP2B)
    GpioCtrlRegs.GPAPUD.bit.GPIO26 = 0;    // Enable pull-up on GPIO26 (EQEP2I)
    GpioCtrlRegs.GPAPUD.bit.GPIO27 = 0;    // Enable pull-up on GPIO27 (EQEP2S)

// Inputs are synchronized to SYSCLKOUT by default.  
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAQSEL2.bit.GPIO24 = 0;  // Sync to SYSCLKOUT GPIO24 (EQEP2A)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO25 = 0;  // Sync to SYSCLKOUT GPIO25 (EQEP2B)               
    GpioCtrlRegs.GPAQSEL2.bit.GPIO26 = 0;  // Sync to SYSCLKOUT GPIO26 (EQEP2I)               
    GpioCtrlRegs.GPAQSEL2.bit.GPIO27 = 0;  // Sync to SYSCLKOUT GPIO27 (EQEP2S)               
                              
/* Configure eQEP-2 pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be eQEP2 functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX2.bit.GPIO24 = 2;   // Configure GPIO24 as EQEP2A
    GpioCtrlRegs.GPAMUX2.bit.GPIO25 = 2;   // Configure GPIO25 as EQEP2B          
    GpioCtrlRegs.GPAMUX2.bit.GPIO26 = 2;   // Configure GPIO26 as EQEP2I          
    GpioCtrlRegs.GPAMUX2.bit.GPIO27 = 2;   // Configure GPIO27 as EQEP2S          


    EDIS;
}
#endif // endif DSP28_2808 || DSP28_2806   




//===========================================================================
// End of file.
//===========================================================================

DSP280x_Gpio.c/ 1113835038  0     0     0       2651      `
// TI File $Revision: /main/2 $
// Checkin $Date: December 2, 2004   11:50:58 $
//###########################################################################
//
// FILE:	DSP280x_Gpio.c
//
// TITLE:	DSP280x General Purpose I/O Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitGpio: 
//---------------------------------------------------------------------------
// This function initializes the Gpio to a known (default) state.
//
// For more details on configuring GPIO's as peripheral functions,
// refer to the individual peripheral examples and/or GPIO setup example. 
void InitGpio(void)
{
   EALLOW;
   
   // Each GPIO pin can be: 
   // a) a GPIO input/output
   // b) peripheral function 1
   // c) peripheral function 2
   // d) peripheral function 3
   // By default, all are GPIO Inputs 
   GpioCtrlRegs.GPAMUX1.all = 0x0000;     // GPIO functionality GPIO0-GPIO15
   GpioCtrlRegs.GPAMUX2.all = 0x0000;     // GPIO functionality GPIO16-GPIO31
   GpioCtrlRegs.GPBMUX1.all = 0x0000;     // GPIO functionality GPIO32-GPIO34

   GpioCtrlRegs.GPADIR.all = 0x0000;      // GPIO0-GPIO31 are GP inputs
   GpioCtrlRegs.GPBDIR.all = 0x0000;      // GPIO32-GPIO34 are inputs   
   
   // Each input can have different qualification
   // a) input synchronized to SYSCLKOUT
   // b) input qualified by a sampling window
   // c) input sent asynchronously (valid for peripheral inputs only)
   GpioCtrlRegs.GPAQSEL1.all = 0x0000;    // GPIO0-GPIO15 Synch to SYSCLKOUT 
   GpioCtrlRegs.GPAQSEL2.all = 0x0000;    // GPIO16-GPIO31 Synch to SYSCLKOUT
   GpioCtrlRegs.GPBQSEL1.all = 0x0000;    // GPIO32-GPIO34 Synch to SYSCLKOUT 

   // Pull-ups can be enabled or disabled. 
   GpioCtrlRegs.GPAPUD.all = 0x0000;      // Pullup's enabled GPIO0-GPIO31
   GpioCtrlRegs.GPBPUD.all = 0x0000;      // Pullup's enabled GPIO32-GPIO34
   //GpioCtrlRegs.GPAPUD.all = 0xFFFF;    // Pullup's disabled GPIO0-GPIO31
   //GpioCtrlRegs.GPBPUD.all = 0xFFFF;    // Pullup's disabled GPIO32-GPIO34
   EDIS;

}	
	
//===========================================================================
// End of file.
//===========================================================================

DSP280x_I2C.c/  1113835038  0     0     0       2758      `
// TI File $Revision: /main/2 $
// Checkin $Date: December 2, 2004   11:55:13 $
//###########################################################################
//
// FILE:	DSP280x_I2C.c
//
// TITLE:	DSP280x SCI Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitI2C: 
//---------------------------------------------------------------------------
// This function initializes the I2C to a known state.
//
void InitI2C(void)
{
	// Initialize I2C-A:

	//tbd...
}	

//---------------------------------------------------------------------------
// Example: InitI2CGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as I2C pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 
// Caution: 
// Only one GPIO pin should be enabled for SDAA operation.
// Only one GPIO pin shoudl be enabled for SCLA operation. 
// Comment out other unwanted lines.

void InitI2CGpio()
{

   EALLOW;
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled disabled by the user.  
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

	GpioCtrlRegs.GPBPUD.bit.GPIO32 = 0;    // Enable pull-up for GPIO32 (SDAA)
	GpioCtrlRegs.GPBPUD.bit.GPIO33 = 0;	   // Enable pull-up for GPIO33 (SCLA)

/* Set qualification for selected pins to asynch only */
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

	GpioCtrlRegs.GPBQSEL1.bit.GPIO32 = 3;  // Asynch input GPIO32 (SDAA)
    GpioCtrlRegs.GPBQSEL1.bit.GPIO33 = 3;  // Asynch input GPIO33 (SCLA)

/* Configure SCI pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be I2C functional pins.
// Comment out other unwanted lines.

	GpioCtrlRegs.GPBMUX1.bit.GPIO32 = 1;   // Configure GPIO32 for SDAA operation
	GpioCtrlRegs.GPBMUX1.bit.GPIO33 = 1;   // Configure GPIO33 for SCLA operation
	
    EDIS;
}


	
//===========================================================================
// End of file.
//===========================================================================
DSP280x_MemCopy/1113835038  222   0     0       1482      `
// TI File $Revision: /main/1 $
// Checkin $Date: December 1, 2004   11:12:01 $
//###########################################################################
//
// FILE:	DSP280x_MemCopy.c
//
// TITLE:	Memory Copy Utility
//
// ASSUMPTIONS:
//
//          
//
// DESCRIPTION:
//
//          This function will copy the specified memory contents from
//          one location to another. 
// 
//          Uint16 *SourceAddr        Pointer to the first word to be moved
//                                    SourceAddr < SourceEndAddr
//          Uint16* SourceEndAddr     Pointer to the last word to be moved
//          Uint16* DestAddr          Pointer to the first destination word
//
//          No checks are made for invalid memory locations or that the
//          end address is > then the first start address.
// 
//          
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"

void MemCopy(Uint16 *SourceAddr, Uint16* SourceEndAddr, Uint16* DestAddr)
{
    while(SourceAddr < SourceEndAddr)
    { 
       *DestAddr++ = *SourceAddr++;
    }
    return;
}

//===========================================================================
// End of file.
//===========================================================================
DSP280x_PieCtrl/1113835038  241   0     0       2543      `
// TI File $Revision: /main/1 $
// Checkin $Date: December 1, 2004   11:12:03 $
//###########################################################################
//
// FILE:	DSP280x_PieCtrl.c
//
// TITLE:	DSP280x Device PIE Control Register Initialization Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitPieCtrl: 
//---------------------------------------------------------------------------
// This function initializes the PIE control registers to a known state.
//
void InitPieCtrl(void)
{
    // Disable Interrupts at the CPU level:
    DINT;

    // Disable the PIE
    PieCtrlRegs.PIECTRL.bit.ENPIE = 0;

	// Clear all PIEIER registers:
	PieCtrlRegs.PIEIER1.all = 0;
	PieCtrlRegs.PIEIER2.all = 0;
	PieCtrlRegs.PIEIER3.all = 0;	
	PieCtrlRegs.PIEIER4.all = 0;
	PieCtrlRegs.PIEIER5.all = 0;
	PieCtrlRegs.PIEIER6.all = 0;
	PieCtrlRegs.PIEIER7.all = 0;
	PieCtrlRegs.PIEIER8.all = 0;
	PieCtrlRegs.PIEIER9.all = 0;
	PieCtrlRegs.PIEIER10.all = 0;
	PieCtrlRegs.PIEIER11.all = 0;
	PieCtrlRegs.PIEIER12.all = 0;

	// Clear all PIEIFR registers:
	PieCtrlRegs.PIEIFR1.all = 0;
	PieCtrlRegs.PIEIFR2.all = 0;
	PieCtrlRegs.PIEIFR3.all = 0;	
	PieCtrlRegs.PIEIFR4.all = 0;
	PieCtrlRegs.PIEIFR5.all = 0;
	PieCtrlRegs.PIEIFR6.all = 0;
	PieCtrlRegs.PIEIFR7.all = 0;
	PieCtrlRegs.PIEIFR8.all = 0;
	PieCtrlRegs.PIEIFR9.all = 0;
	PieCtrlRegs.PIEIFR10.all = 0;
	PieCtrlRegs.PIEIFR11.all = 0;
	PieCtrlRegs.PIEIFR12.all = 0;


}	

//---------------------------------------------------------------------------
// EnableInterrupts: 
//---------------------------------------------------------------------------
// This function enables the PIE module and CPU interrupts
//
void EnableInterrupts()
{

    // Enable the PIE
    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;
    		
	// Enables PIE to drive a pulse into the CPU 
	PieCtrlRegs.PIEACK.all = 0xFFFF;  

	// Enable Interrupts at the CPU level 
    EINT;

}


//===========================================================================
// End of file.
//===========================================================================

DSP280x_PieVect/1113835038  260   0     0       7060      `
// TI File $Revision: /main/1 $
// Checkin $Date: December 1, 2004   11:12:05 $
//###########################################################################
//
// FILE:	DSP280x_PieVect.c
//
// TITLE:	DSP280x Devices PIE Vector Table Initialization Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File


const struct PIE_VECT_TABLE PieVectTableInit = {

      PIE_RESERVED,  // 0  Reserved space
      PIE_RESERVED,  // 1  Reserved space 
      PIE_RESERVED,  // 2  Reserved space 
      PIE_RESERVED,  // 3  Reserved space 
      PIE_RESERVED,  // 4  Reserved space 
      PIE_RESERVED,  // 5  Reserved space 
      PIE_RESERVED,  // 6  Reserved space 
      PIE_RESERVED,  // 7  Reserved space 
      PIE_RESERVED,  // 8  Reserved space 
      PIE_RESERVED,  // 9  Reserved space 
      PIE_RESERVED,  // 10 Reserved space 
      PIE_RESERVED,  // 11 Reserved space 
      PIE_RESERVED,  // 12 Reserved space 


// Non-Peripheral Interrupts
      INT13_ISR,     // XINT13 or CPU-Timer 1
      INT14_ISR,     // CPU-Timer2
      DATALOG_ISR,   // Datalogging interrupt
      RTOSINT_ISR,   // RTOS interrupt
      EMUINT_ISR,    // Emulation interrupt
      NMI_ISR,       // Non-maskable interrupt
      ILLEGAL_ISR,   // Illegal operation TRAP
      USER1_ISR,     // User Defined trap 1
      USER2_ISR,     // User Defined trap 2
      USER3_ISR,     // User Defined trap 3
      USER4_ISR,     // User Defined trap 4
      USER5_ISR,     // User Defined trap 5
      USER6_ISR,     // User Defined trap 6
      USER7_ISR,     // User Defined trap 7
      USER8_ISR,     // User Defined trap 8
      USER9_ISR,     // User Defined trap 9
      USER10_ISR,    // User Defined trap 10
      USER11_ISR,    // User Defined trap 11
      USER12_ISR,    // User Defined trap 12

// Group 1 PIE Vectors
      SEQ1INT_ISR,     // 1.1 ADC  
      SEQ2INT_ISR,     // 1.2 ADC  
      rsvd_ISR,        // 1.3
      XINT1_ISR,       // 1.4     
      XINT2_ISR,       // 1.5
      ADCINT_ISR,      // 1.6 ADC
      TINT0_ISR,       // 1.7 Timer 0
      WAKEINT_ISR,     // 1.8 WD, Low Power

// Group 2 PIE Vectors
      EPWM1_TZINT_ISR, // 2.1 EPWM-1 Trip Zone
      EPWM2_TZINT_ISR, // 2.2 EPWM-2 Trip Zone
      EPWM3_TZINT_ISR, // 2.3 EPWM-3 Trip Zone
      EPWM4_TZINT_ISR, // 2.4 EPWM-4 Trip Zone
      EPWM5_TZINT_ISR, // 2.5 EPWM-5 Trip Zone
      EPWM6_TZINT_ISR, // 2.6 EPWM-6 Trip Zone                        
      rsvd_ISR,        // 2.7
      rsvd_ISR,        // 2.8
      
// Group 3 PIE Vectors
      EPWM1_INT_ISR,   // 3.1 EPWM-1 Interrupt
      EPWM2_INT_ISR,   // 3.2 EPWM-2 Interrupt
      EPWM3_INT_ISR,   // 3.3 EPWM-3 Interrupt
      EPWM4_INT_ISR,   // 3.4 EPWM-4 Interrupt
      EPWM5_INT_ISR,   // 3.5 EPWM-5 Interrupt
      EPWM6_INT_ISR,   // 3.6 EPWM-6 Interrupt                        
      rsvd_ISR,        // 3.7
      rsvd_ISR,        // 3.8
      
// Group 4 PIE Vectors
      ECAP1_INT_ISR,   // 4.1 ECAP-1
      ECAP2_INT_ISR,   // 4.2 ECAP-2
      ECAP3_INT_ISR,   // 4.3 ECAP-3
      ECAP4_INT_ISR,   // 4.4 ECAP-4            
      rsvd_ISR,        // 4.5      
      rsvd_ISR,        // 4.6           
      rsvd_ISR,        // 4.7      
      rsvd_ISR,        // 4.8      
      
// Group 5 PIE Vectors
      EQEP1_INT_ISR,   // 5.1 EQEP-1
      EQEP2_INT_ISR,   // 5.2 EQEP-2
      rsvd_ISR,        // 5.3      
      rsvd_ISR,        // 5.4           
      rsvd_ISR,        // 5.5      
      rsvd_ISR,        // 5.6      
      rsvd_ISR,        // 5.7      
      rsvd_ISR,        // 5.8   


// Group 6 PIE Vectors
      SPIRXINTA_ISR,   // 6.1 SPI-A
      SPITXINTA_ISR,   // 6.2 SPI-A
      SPIRXINTB_ISR,   // 6.3 SPI-B
      SPITXINTB_ISR,   // 6.4 SPI-B
      SPIRXINTC_ISR,   // 6.5 SPI-C
      SPITXINTC_ISR,   // 6.6 SPI-C
      SPIRXINTD_ISR,   // 6.7 SPI-D
      SPITXINTD_ISR,   // 6.8 SPI-D                  

      
// Group 7 PIE Vectors
      rsvd_ISR,        // 7.1      
      rsvd_ISR,        // 7.2
      rsvd_ISR,        // 7.3      
      rsvd_ISR,        // 7.4           
      rsvd_ISR,        // 7.5      
      rsvd_ISR,        // 7.6      
      rsvd_ISR,        // 7.7      
      rsvd_ISR,        // 7.8   

// Group 8 PIE Vectors
      I2CINT1A_ISR,    // 8.1      
      I2CINT2A_ISR,    // 8.2
      rsvd_ISR,        // 8.3      
      rsvd_ISR,        // 8.4           
      rsvd_ISR,        // 8.5      
      rsvd_ISR,        // 8.6      
      rsvd_ISR,        // 8.7      
      rsvd_ISR,        // 8.8    
      
// Group 9 PIE Vectors     
      SCIRXINTA_ISR,   // 9.1 SCI-A
      SCITXINTA_ISR,   // 9.2 SCI-A
      SCIRXINTB_ISR,   // 9.3 SCI-B
      SCITXINTB_ISR,   // 9.4 SCI-B
      ECAN0INTA_ISR,   // 9.5 eCAN-A
      ECAN1INTA_ISR,   // 9.6 eCAN-A
      ECAN0INTB_ISR,   // 9.7 eCAN-B
      ECAN1INTB_ISR,   // 9.8 eCAN-B
      
// Group 10 PIE Vectors
      rsvd_ISR,        // 10.1      
      rsvd_ISR,        // 10.2
      rsvd_ISR,        // 10.3      
      rsvd_ISR,        // 10.4           
      rsvd_ISR,        // 10.5      
      rsvd_ISR,        // 10.6      
      rsvd_ISR,        // 10.7      
      rsvd_ISR,        // 10.8    
            
// Group 11 PIE Vectors
      rsvd_ISR,        // 11.1      
      rsvd_ISR,        // 11.2
      rsvd_ISR,        // 11.3      
      rsvd_ISR,        // 11.4           
      rsvd_ISR,        // 11.5      
      rsvd_ISR,        // 11.6      
      rsvd_ISR,        // 11.7      
      rsvd_ISR,        // 11.8
        
// Group 12 PIE Vectors
      rsvd_ISR,        // 12.1      
      rsvd_ISR,        // 12.2
      rsvd_ISR,        // 12.3      
      rsvd_ISR,        // 12.4           
      rsvd_ISR,        // 12.5      
      rsvd_ISR,        // 12.6      
      rsvd_ISR,        // 12.7      
      rsvd_ISR,        // 12.8   
};


//---------------------------------------------------------------------------
// InitPieVectTable: 
//---------------------------------------------------------------------------
// This function initializes the PIE vector table to a known state.
// This function must be executed after boot time.
//

void InitPieVectTable(void)
{
	int16	i;
	Uint32 *Source = (void *) &PieVectTableInit;
	Uint32 *Dest = (void *) &PieVectTable;
		
	EALLOW;	
	for(i=0; i < 128; i++)
		*Dest++ = *Source++;	
	EDIS;

	// Enable the PIE Vector Table
	PieCtrlRegs.PIECTRL.bit.ENPIE = 1;	
			
}

//===========================================================================
// End of file.
//===========================================================================
DSP280x_Sci.c/  1113835038  0     0     0       5173      `
// TI File $Revision: /main/2 $
// Checkin $Date: December 2, 2004   11:59:53 $
//###########################################################################
//
// FILE:	DSP280x_Sci.c
//
// TITLE:	DSP280x SCI Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitSci: 
//---------------------------------------------------------------------------
// This function initializes the SCI(s) to a known state.
//
void InitSci(void)
{
	// Initialize SCI-A:

	//tbd...
 	

	// Initialize SCI-B:

	//tbd...
}	

//---------------------------------------------------------------------------
// Example: InitSciGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as SCI pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 
// Caution: 
// Only one GPIO pin should be enabled for SCITXDA/B operation.
// Only one GPIO pin shoudl be enabled for SCIRXDA/B operation. 
// Comment out other unwanted lines.

void InitSciGpio()
{
   InitSciaGpio();
#if DSP28_2808 || DSP28_2806   
   InitScibGpio();
#endif // if DSP28_2808 || DSP28_2806  
}

void InitSciaGpio()
{
   EALLOW;

/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled disabled by the user.  
// This will enable the pullups for the specified pins.

	GpioCtrlRegs.GPAPUD.bit.GPIO28 = 0;    // Enable pull-up for GPIO28 (SCIRXDA)
	GpioCtrlRegs.GPAPUD.bit.GPIO29 = 0;	   // Enable pull-up for GPIO29 (SCITXDA)

/* Set qualification for selected pins to asynch only */
// Inputs are synchronized to SYSCLKOUT by default.  
// This will select asynch (no qualification) for the selected pins.

	GpioCtrlRegs.GPAQSEL2.bit.GPIO28 = 3;  // Asynch input GPIO28 (SCIRXDA)

/* Configure SCI-A pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be SCI functional pins.

	GpioCtrlRegs.GPAMUX2.bit.GPIO28 = 1;   // Configure GPIO28 for SCIRXDA operation
	GpioCtrlRegs.GPAMUX2.bit.GPIO29 = 1;   // Configure GPIO29 for SCITXDA operation
	
    EDIS;
}

#if DSP28_2808 || DSP28_2806 
void InitScibGpio()
{
   EALLOW;
	
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled disabled by the user.  
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

//  GpioCtrlRegs.GPAPUD.bit.GPIO9 = 0;     // Enable pull-up for GPIO9  (SCITXDB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO14 = 0;    // Enable pull-up for GPIO14 (SCITXDB)
	GpioCtrlRegs.GPAPUD.bit.GPIO18 = 0;	   // Enable pull-up for GPIO18 (SCITXDB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO22 = 0;    // Enable pull-up for GPIO22 (SCITXDB)

	
//  GpioCtrlRegs.GPAPUD.bit.GPIO11 = 0;    // Enable pull-up for GPIO11 (SCIRXDB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO15 = 0;    // Enable pull-up for GPIO15 (SCIRXDB)
    GpioCtrlRegs.GPAPUD.bit.GPIO19 = 0;	   // Enable pull-up for GPIO19 (SCIRXDB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO23 = 0;    // Enable pull-up for GPIO23 (SCIRXDB)

/* Set qualification for selected pins to asynch only */
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

//  GpioCtrlRegs.GPAQSEL1.bit.GPIO11 = 3;  // Asynch input GPIO11 (SCIRXDB)
//  GpioCtrlRegs.GPAQSEL1.bit.GPIO15 = 3;  // Asynch input GPIO15 (SCIRXDB)
	GpioCtrlRegs.GPAQSEL2.bit.GPIO19 = 3;  // Asynch input GPIO19 (SCIRXDB)
//  GpioCtrlRegs.GPAQSEL2.bit.GPIO23 = 3;  // Asynch input GPIO23 (SCIRXDB)

/* Configure SCI-B pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be SCI functional pins.
// Comment out other unwanted lines.

//  GpioCtrlRegs.GPAMUX1.bit.GPIO9 = 2;    // Configure GPIO9 for SCITXDB operation
//  GpioCtrlRegs.GPAMUX1.bit.GPIO14 = 2;   // Configure GPIO14 for SCITXDB operation
	GpioCtrlRegs.GPAMUX2.bit.GPIO18 = 2;   // Configure GPIO18 for SCITXDB operation
//  GpioCtrlRegs.GPAMUX2.bit.GPIO22 = 3;   // Configure GPIO22 for SCITXDB operation
	
//  GpioCtrlRegs.GPAMUX1.bit.GPIO11 = 2;   // Configure GPIO11 for SCIRXDB operation
//  GpioCtrlRegs.GPAMUX1.bit.GPIO15 = 2;   // Configure GPIO15 for SCIRXDB operation
    GpioCtrlRegs.GPAMUX2.bit.GPIO19 = 2;   // Configure GPIO19 for SCIRXDB operation
//  GpioCtrlRegs.GPAMUX2.bit.GPIO23 = 3;   // Configure GPIO23 for SCIRXDB operation
	
    EDIS;
}
#endif // if DSP28_2808 || DSP2806 


	
//===========================================================================
// End of file.
//===========================================================================

DSP280x_Spi.c/  1113835038  0     0     0       11287     `
// TI File $Revision: /main/3 $
// Checkin $Date: December 2, 2004   15:16:48 $
//###########################################################################
//
// FILE:   DSP280x_Spi.c
//
// TITLE:  DSP280x SPI Initialization & Support Functions.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File

//---------------------------------------------------------------------------
// InitSPI: 
//---------------------------------------------------------------------------
// This function initializes the SPI(s) to a known state.
//
void InitSpi(void)
{
   // Initialize SPI-A/B/C/D

   //tbd...
 
}

//---------------------------------------------------------------------------
// Example: InitSpiGpio: 
//---------------------------------------------------------------------------
// This function initializes GPIO pins to function as SPI pins
//
// Each GPIO pin can be configured as a GPIO pin or up to 3 different
// peripheral functional pins. By default all pins come up as GPIO
// inputs after reset.  
// 
// Caution: 
// For each SPI peripheral
// Only one GPIO pin should be enabled for SPISOMO operation.
// Only one GPIO pin should be enabled for SPISOMI operation. 
// Only one GPIO pin should be enabled for SPICLKA operation. 
// Only one GPIO pin should be enabled for SPISTEA operation. 
// Comment out other unwanted lines.

void InitSpiGpio()
{

   InitSpiaGpio();
   InitSpibGpio();
#if DSP28_2808 || DSP28_2806     
   InitSpicGpio();
   InitSpidGpio();
#endif // endif DSP28_2808 || DSP28_2806     
}

void InitSpiaGpio()
{

   EALLOW;
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled by the user.  
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO16 = 0;   // Enable pull-up on GPIO16 (SPISIMOA)
    GpioCtrlRegs.GPAPUD.bit.GPIO17 = 0;   // Enable pull-up on GPIO17 (SPISOMIA)
    GpioCtrlRegs.GPAPUD.bit.GPIO18 = 0;   // Enable pull-up on GPIO18 (SPICLKA)
    GpioCtrlRegs.GPAPUD.bit.GPIO19 = 0;   // Enable pull-up on GPIO19 (SPISTEA)


/* Set qualification for selected pins to asynch only */
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAQSEL2.bit.GPIO16 = 3; // Asynch input GPIO16 (SPISIMOA)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO17 = 3; // Asynch input GPIO17 (SPISOMIA)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO18 = 3; // Asynch input GPIO18 (SPICLKA)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO19 = 3; // Asynch input GPIO19 (SPISTEA)
    
/* Configure SPI-A pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be SPI functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX2.bit.GPIO16 = 1; // Configure GPIO16 as SPISIMOA
    GpioCtrlRegs.GPAMUX2.bit.GPIO17 = 1; // Configure GPIO17 as SPISOMIA
    GpioCtrlRegs.GPAMUX2.bit.GPIO18 = 1; // Configure GPIO18 as SPICLKA
    GpioCtrlRegs.GPAMUX2.bit.GPIO19 = 1; // Configure GPIO19 as SPISTEA

    EDIS;
}

void InitSpibGpio()
{
   EALLOW;
    	
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled disabled by the user.  
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO12 = 0;     // Enable pull-up on GPIO12 (SPISIMOB)
//  GpioCtrlRegs.GPAPUD.bit.GPIO24 = 0;     // Enable pull-up on GPIO24 (SPISIMOB)

    GpioCtrlRegs.GPAPUD.bit.GPIO13 = 0;     // Enable pull-up on GPIO13 (SPISOMIB)                                                                           
//  GpioCtrlRegs.GPAPUD.bit.GPIO25 = 0;     // Enable pull-up on GPIO25 (SPISOMIB)

    GpioCtrlRegs.GPAPUD.bit.GPIO14 = 0;     // Enable pull-up on GPIO14 (SPICLKB)                                                                           
//  GpioCtrlRegs.GPAPUD.bit.GPIO26 = 0;     // Enable pull-up on GPIO26 (SPICLKB) 

    GpioCtrlRegs.GPAPUD.bit.GPIO15 = 0;     // Enable pull-up on GPIO15 (SPISTEB)                                                                           
//  GpioCtrlRegs.GPAPUD.bit.GPIO27 = 0;     // Enable pull-up on GPIO27 (SPISTEB) 

    
/* Set qualification for selected pins to asynch only */
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAQSEL1.bit.GPIO12 = 3;   // Asynch input GPIO12 (SPISIMOB)
//  GpioCtrlRegs.GPAQSEL2.bit.GPIO24 = 3;   // Asynch input GPIO24 (SPISIMOB)

    GpioCtrlRegs.GPAQSEL1.bit.GPIO13 = 3;   // Asynch input GPIO13 (SPISOMIB)                                                                                       
//  GpioCtrlRegs.GPAQSEL2.bit.GPIO25 = 3;   // Asynch input GPIO25 (SPISOMIB)

    GpioCtrlRegs.GPAQSEL1.bit.GPIO14 = 3;   // Asynch input GPIO14 (SPICLKB)                                                                                        
//  GpioCtrlRegs.GPAQSEL2.bit.GPIO26 = 3;   // Asynch input GPIO26 (SPICLKB) 

    GpioCtrlRegs.GPAQSEL1.bit.GPIO15 = 3;   // Asynch input GPIO15 (SPISTEB)                                                                                        
//  GpioCtrlRegs.GPAQSEL2.bit.GPIO27 = 3;   // Asynch input GPIO27 (SPISTEB) 

/* Configure SPI-B pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be SPI functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO12 = 3;    // Configure GPIO12 as SPISIMOB
//  GpioCtrlRegs.GPAMUX2.bit.GPIO24 = 3;    // Configure GPIO24 as SPISIMOB
         
    GpioCtrlRegs.GPAMUX1.bit.GPIO13 = 3;    // Configure GPIO13 as SPISOMIB     
//  GpioCtrlRegs.GPAMUX2.bit.GPIO25 = 3;    // Configure GPIO25 as SPISOMIB         

    GpioCtrlRegs.GPAMUX1.bit.GPIO14 = 3;    // Configure GPIO14 as SPICLKB     
//  GpioCtrlRegs.GPAMUX2.bit.GPIO26 = 3;    // Configure GPIO26 as SPICLKB         

    GpioCtrlRegs.GPAMUX1.bit.GPIO15 = 3;    // Configure GPIO15 as SPISTEB     
//  GpioCtrlRegs.GPAMUX2.bit.GPIO27 = 3;    // Configure GPIO27 as SPISTEB         

    EDIS;
}   

#if DSP28_2808 || DSP28_2806
void InitSpicGpio()
{
   EALLOW;
    	
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled disabled by the user.  
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO20 = 0;   // Enable pull-up on GPIO20 (SPISIMOC)
    GpioCtrlRegs.GPAPUD.bit.GPIO21 = 0;   // Enable pull-up on GPIO21 (SPISOMIC)                                                                                                             
    GpioCtrlRegs.GPAPUD.bit.GPIO22 = 0;   // Enable pull-up on GPIO22 (SPICLKC)                                                                                                             
    GpioCtrlRegs.GPAPUD.bit.GPIO23 = 0;   // Enable pull-up on GPIO23 (SPISTEC)                                                                                                             
    
/* Set qualification for selected pins to asynch only */
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAQSEL2.bit.GPIO20 = 3;   // Asynch input GPIO20 (SPISIMOC)
    GpioCtrlRegs.GPAQSEL2.bit.GPIO21 = 3;   // Asynch input GPIO21 (SPISOMIC)                                                                                                                           
    GpioCtrlRegs.GPAQSEL2.bit.GPIO22 = 3;   // Asynch input GPIO22 (SPICLKC)                                                                                                                            
    GpioCtrlRegs.GPAQSEL2.bit.GPIO23 = 3;   // Asynch input GPIO23 (SPISTEC)                                                                                                                            

/* Configure SPI-C pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be SPI functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX2.bit.GPIO20 = 2;   // Configure GPIO20 as SPISIMOC
    GpioCtrlRegs.GPAMUX2.bit.GPIO21 = 2;   // Configure GPIO21 as SPISOMIC     
    GpioCtrlRegs.GPAMUX2.bit.GPIO22 = 2;   // Configure GPIO22 as SPICLKC    
    GpioCtrlRegs.GPAMUX2.bit.GPIO23 = 2;   // Configure GPIO23 as SPISTEC     

    EDIS;
}
#endif // endif DSP28_2808 || DSP28_2806   


#if DSP28_2808 || DSP28_2806
void InitSpidGpio()
{
   EALLOW;
/* Enable internal pull-up for the selected pins */
// Pull-ups can be enabled or disabled disabled by the user.  
// This will enable the pullups for the specified pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAPUD.bit.GPIO1 = 0;    // Enable pull-up on GPIO1 (SPISIMOD)
    GpioCtrlRegs.GPAPUD.bit.GPIO3 = 0;    // Enable pull-up on GPIO3 (SPISOMID)  
    GpioCtrlRegs.GPAPUD.bit.GPIO5 = 0;    // Enable pull-up on GPIO5 (SPICLKD)                                                                                                                       
    GpioCtrlRegs.GPAPUD.bit.GPIO7 = 0;    // Enable pull-up on GPIO7 (SPISTED)                                                                                                                       
    
/* Set qualification for selected pins to asynch only */
// This will select asynch (no qualification) for the selected pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAQSEL1.bit.GPIO1 = 3;   // Asynch input GPIO1 (SPISIMOD)
    GpioCtrlRegs.GPAQSEL1.bit.GPIO3 = 3;   // Asynch input GPIO3 (SPISOMID)                                                                                                                                     
    GpioCtrlRegs.GPAQSEL1.bit.GPIO5 = 3;   // Asynch input GPIO5 (SPICLKD)                                                                                                                                      
    GpioCtrlRegs.GPAQSEL1.bit.GPIO7 = 3;   // Asynch input GPIO7 (SPISTED)                                                                                                                                      

/* Configure SPI-D pins using GPIO regs*/
// This specifies which of the possible GPIO pins will be SPI functional pins.
// Comment out other unwanted lines.

    GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 2;   // Configure GPIO1 as SPISIMOD
    GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 2;   // Configure GPIO3 as SPISOMID     
    GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 2;   // Configure GPIO5 as SPICLKD   
    GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 2;   // Configure GPIO7 as SPISTED     

    EDIS;
}   
#endif // endif DSP28_2808 || DSP28_2806  



//===========================================================================
// End of file.
//===========================================================================

DSP280x_SWPrior/1113835038  279   0     0       39648     `
// TI File $Revision: /main/1 $
// Checkin $Date: December 1, 2004   17:04:36 $
//###########################################################################
//
// FILE:    DSP280x_SWPrioritizedDefaultIsr.c
//
// TITLE:   DSP280x Device Default Software Prioritized Interrupt Service Routines.
//
//###########################################################################
//
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################


#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File
#include "DSP280x_SWPrioritizedIsrLevels.h" 


// Connected to INT13 of CPU (use MINT13 mask):
// Note CPU-Timer1 is reserved for TI use, however XINT13
// ISR can be used by the user. 
#if (INT13PL != 0)
interrupt void INT13_ISR(void)     // INT13 or CPU-Timer1
{
	 IER |= MINT13;                 // Set "global" priority
	 EINT;

  // Insert ISR Code here
  
  // Next two lines for debug only to halt the processor here
  // Remove after inserting ISR Code
     asm ("      ESTOP0");
     for(;;);
}
#endif

// Connected to INT14 of CPU (use MINT14 mask):
#if (INT14PL != 0)
interrupt void INT14_ISR(void)     // CPU-Timer2
{
   IER |= MINT14;                  // Set "global" priority
   EINT;

   // Insert ISR Code here.......
  
   // Next two lines for debug only to halt the processor here
   // Remove after inserting ISR Code
   asm ("      ESTOP0");
   for(;;);
}
#endif

// Connected to INT15 of CPU (use MINT15 mask):
#if (INT15PL != 0)
interrupt void DATALOG_ISR(void)   // Datalogging interrupt
{
	IER |= MINT15;                 // Set "global" priority
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}
#endif

// Connected to INT16 of CPU (use MINT16 mask):
#if (INT16PL != 0)
interrupt void RTOSINT_ISR(void)   // RTOS interrupt
{
	IER |= MINT16;                 // Set "global" priority
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}
#endif

// Connected to EMUINT of CPU (non-maskable):
interrupt void EMUINT_ISR(void)    // Emulation interrupt
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}


// Connected to NMI of CPU (non-maskable):
interrupt void NMI_ISR(void)      // Non-maskable interrupt
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void ILLEGAL_ISR(void)   // Illegal operation TRAP
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}


interrupt void USER1_ISR(void)     // User Defined trap 1
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER2_ISR(void)     // User Defined trap 2
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER3_ISR(void)     // User Defined trap 3
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER4_ISR(void)     // User Defined trap 4
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER5_ISR(void)     // User Defined trap 5
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER6_ISR(void)     // User Defined trap 6
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER7_ISR(void)     // User Defined trap 7
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER8_ISR(void)     // User Defined trap 8
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER9_ISR(void)     // User Defined trap 9
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER10_ISR(void)    // User Defined trap 10
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER11_ISR(void)    // User Defined trap 11
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}

interrupt void USER12_ISR(void)     // User Defined trap 12
{
	EINT;

  	// Insert ISR Code here.......
  
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}


// -----------------------------------------------------------
// PIE Group 1 - MUXed into CPU INT1
// -----------------------------------------------------------

// Connected to PIEIER1_1 (use MINT1 and MG11 masks):
#if (G11PL != 0)
interrupt void SEQ1INT_ISR( void )     // ADC
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER1.all;
	IER |= M_INT1;
	IER	&= MINT1;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER1.all &= MG11;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER1.all = TempPIEIER;
    
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER1_2 (use MINT1 and MG12 masks):
#if (G12PL != 0)
interrupt void SEQ2INT_ISR( void )    // ADC
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER1.all;
	IER |= M_INT1;
	IER	&= MINT1;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER1.all &= MG12;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
  	


	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER1.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif


// Connected to PIEIER1_4 (use MINT1 and MG14 masks):
#if (G14PL != 0)
interrupt void  XINT1_ISR(void)
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER1.all;
	IER |= MINT1;                      // Set "global" priority
	PieCtrlRegs.PIEIER1.all &= MG14;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;


	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER1.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif

// Connected to PIEIER1_5 (use MINT1 and MG15 masks):
#if (G15PL != 0)
interrupt void  XINT2_ISR(void)
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER1.all;
	IER |= MINT1;                      // Set "global" priority
	PieCtrlRegs.PIEIER1.all &= MG15;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
  	

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER1.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}
#endif


// Connected to PIEIER1_6 (use MINT1 and MG16 masks):
#if (G16PL != 0)
interrupt void  ADCINT_ISR(void)     // ADC
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT1;
	IER	&= MINT1;                      // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG16;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER1_7 (use MINT1 and MG17 masks):
#if (G17PL != 0)
interrupt void  TINT0_ISR(void)      // CPU-Timer 0
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER1.all;
	IER |= M_INT1;
	IER	&= MINT1;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER1.all &= MG17;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
  	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER1.all = TempPIEIER;
      
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif

// Connected to PIEIER1_8 (use MINT1 and MG18 masks):
#if (G18PL != 0)
interrupt void  WAKEINT_ISR(void)      // WD/LPM
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER1.all;
	IER |= M_INT1;
	IER	&= MINT1;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER1.all &= MG18;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
  	
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER1.all = TempPIEIER;
	
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif


// -----------------------------------------------------------
// PIE Group 2 - MUXed into CPU INT2
// -----------------------------------------------------------

// Connected to PIEIER2_1 (use MINT2 and MG21 masks):
#if (G21PL != 0)
interrupt void EPWM1_TZINT_ISR(void)    // ePWM1 Trip Zone
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER2.all;
	IER |= M_INT2;
	IER	&= MINT2;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER2.all &= MG21;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER2.all = TempPIEIER;
    
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif

// Connected to PIEIER2_2 (use MINT2 and MG22 masks):
#if (G22PL != 0)
interrupt void EPWM2_TZINT_ISR(void)    // ePWM2 Trip Zone
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER2.all;
	IER |= M_INT2;
	IER	&= MINT2;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER2.all &= MG22;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER2.all = TempPIEIER;
	
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif

// Connected to PIEIER2_3 (use MINT2 and MG23 masks):
#if (G23PL != 0)
interrupt void EPWM3_TZINT_ISR(void)    // ePWM3 Trip Zone
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER2.all;
	IER |= M_INT2;
	IER	&= MINT2;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER2.all &= MG23;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER2.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER2_4 (use MINT2 and MG24 masks):
#if (G24PL != 0)
interrupt void EPWM4_TZINT_ISR(void)    // ePWM4 Trip Zone
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER2.all;
	IER |= M_INT2;
	IER	&= MINT2;	  	                // Set "global" priority
	PieCtrlRegs.PIEIER2.all &= MG24;    // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;    // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER2.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER2_5 (use MINT2 and MG25 masks):
#if (G25PL != 0)
interrupt void EPWM5_TZINT_ISR(void)    // ePWM5 Trip Zone
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER2.all;
	IER |= M_INT2;
	IER	&= MINT2;	  	                // Set "global" priority
	PieCtrlRegs.PIEIER2.all &= MG25;    // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;    // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER2.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER2_6 (use MINT2 and MG26 masks):
#if (G26PL != 0)
interrupt void EPWM6_TZINT_ISR(void)    // ePWM6 Trip Zone
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER2.all;
	IER |= M_INT2;
	IER	&= MINT2;	  	                // Set "global" priority
	PieCtrlRegs.PIEIER2.all &= MG26;    // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;    // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER2.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif


// -----------------------------------------------------------
// PIE Group 3 - MUXed into CPU INT3
// -----------------------------------------------------------


// Connected to PIEIER3_1 (use MINT3 and MG31 masks):
#if (G31PL != 0)
interrupt void EPWM1_INT_ISR(void)     // ePWM1 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER3.all;
	IER |= M_INT3;
	IER	&= MINT3;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER3.all &= MG31;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER3.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif

// Connected to PIEIER3_2 (use MINT3 and MG32 masks):
#if (G32PL != 0)
interrupt void EPWM2_INT_ISR(void)     // ePWM2 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER3.all;
	IER |= M_INT3;
	IER	&= MINT3;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER3.all &= MG32;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER3.all = TempPIEIER;
    
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif
      
// Connected to PIEIER3_3 (use MINT3 and MG33 masks):
#if (G33PL != 0)
interrupt void EPWM3_INT_ISR(void)     // ePWM3 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER3.all;
	IER |= M_INT3;
	IER	&= MINT3;	  	                // Set "global" priority
	PieCtrlRegs.PIEIER3.all &= MG33;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER3.all = TempPIEIER;
      
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER3_4 (use MINT3 and MG34 masks):
#if (G34PL != 0)
interrupt void EPWM4_INT_ISR(void)     // ePWM4 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER3.all;
	IER |= M_INT3;
	IER	&= MINT3;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER3.all &= MG34;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER3.all = TempPIEIER;
      
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER3_5 (use MINT3 and MG35 masks):
#if (G35PL != 0)
interrupt void EPWM5_INT_ISR(void)     // ePWM5 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER3.all;
	IER |= M_INT3;
	IER	&= MINT3;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER3.all &= MG35;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER3.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER3_6 (use MINT3 and MG36 masks):
#if (G36PL != 0)
interrupt void EPWM6_INT_ISR(void)     // ePWM6 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER3.all;
	IER |= M_INT3;
	IER	&= MINT3;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER3.all &= MG36;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER3.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif


// -----------------------------------------------------------
// PIE Group 4 - MUXed into CPU INT4
// -----------------------------------------------------------


// Connected to PIEIER4_1 (use MINT4 and MG41 masks):
#if (G41PL != 0)
interrupt void ECAP1_INT_ISR(void)     // eCAP1 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER4.all;
	IER |= M_INT4;
	IER	&= MINT4;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER4.all &= MG41;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER4.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER4_2 (use MINT4 and MG42 masks):
#if (G42PL != 0)
interrupt void ECAP2_INT_ISR(void)     // eCAP2 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER5.all;
	IER |= M_INT4;
	IER	&= MINT4;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER4.all &= MG42;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER4.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER4_3 (use MINT4 and MG43 masks):
#if (G43PL != 0)
interrupt void ECAP3_INT_ISR(void)     // eCAP3 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER4.all;
	IER |= M_INT4;
	IER	&= MINT4;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER4.all &= MG43;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER4.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER4_4 (use MINT4 and MG44 masks):
#if (G44PL != 0)
interrupt void ECAP4_INT_ISR(void)     // eCAP4 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER4.all;
	IER |= M_INT4;
	IER	&= MINT4;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER4.all &= MG44;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
 
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER4.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif


// -----------------------------------------------------------
// PIE Group 5 - MUXed into CPU INT5
// -----------------------------------------------------------

// Connected to PIEIER5_1 (use MINT5 and MG51 masks):
#if (G51PL != 0)
interrupt void EQEP1_INT_ISR(void)     // eQEP1 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER5.all;
	IER |= M_INT5;
	IER	&= MINT5;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER5.all &= MG51;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER5.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER5_2 (use MINT5 and MG52 masks):
#if (G52PL != 0)
interrupt void EQEP2_INT_ISR(void)     // eQEP2 Interrupt
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER5.all;
	IER |= M_INT5;
	IER	&= MINT5;	  	                // Set "global" priority
	PieCtrlRegs.PIEIER5.all &= MG52;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER5.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif
      
// -----------------------------------------------------------
// PIE Group 6 - MUXed into CPU INT6
// -----------------------------------------------------------

// Connected to PIEIER6_1 (use MINT6 and MG61 masks):
#if (G61PL != 0)
interrupt void SPIRXINTA_ISR(void)    // SPI-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG61;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER6_2 (use MINT6 and MG62 masks):
#if (G62PL != 0)
interrupt void SPITXINTA_ISR(void)     // SPI-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG62;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);
}     
#endif

// Connected to PIEIER6_3 (use MINT6 and MG63 masks):
#if (G63PL != 0)
interrupt void SPIRXINTB_ISR(void)    // SPI-B
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG63;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;
	
    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER6_4 (use MINT6 and MG64 masks):
#if (G64PL != 0)
interrupt void SPITXINTB_ISR(void)     // SPI-B
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG64;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
 
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif



// Connected to PIEIER6_5 (use MINT6 and MG65 masks):
#if (G65PL != 0)
interrupt void SPIRXINTC_ISR(void)     // SPI-C
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG65;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER6_6 (use MINT6 and MG66 masks):
#if (G66PL != 0)
interrupt void SPITXINTC_ISR(void)     // SPI-C
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG66;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER6_7 (use MINT6 and MG67 masks):
#if (G65PL != 0)
interrupt void SPIRXINTD_ISR(void)     // SPI-D
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG67;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
 	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER6_8 (use MINT6 and MG68 masks):
#if (G66PL != 0)
interrupt void SPITXINTD_ISR(void)     // SPI-D
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER6.all;
	IER |= M_INT6;
	IER	&= MINT6;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG68;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER6.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif



// -----------------------------------------------------------
// PIE Group 7 - MUXed into CPU INT7
// -----------------------------------------------------------

// -----------------------------------------------------------
// PIE Group 8 - MUXed into CPU INT8
// -----------------------------------------------------------

// Connected to PIEIER8_1 (use MINT8 and MG81 masks):
#if (G81PL != 0)
interrupt void I2CINT1A_ISR(void)    // I2C-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER8.all;
	IER |= M_INT8;
	IER	&= MINT8;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG81;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER8.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER8_2 (use MINT8 and MG82 masks):
#if (G82PL != 0)
interrupt void I2CINT2A_ISR(void)     // I2C-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER8.all;
	IER |= M_INT8;
	IER	&= MINT8;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER6.all &= MG82;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER8.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// -----------------------------------------------------------
// PIE Group 9 - MUXed into CPU INT9
// -----------------------------------------------------------

// Connected to PIEIER9_1 (use MINT9 and MG91 masks):
#if (G91PL != 0)
interrupt void SCIRXINTA_ISR(void)     // SCI-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	                // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG91;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER9_2 (use MINT9 and MG92 masks):
#if (G92PL != 0)
interrupt void SCITXINTA_ISR(void)     // SCI-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG92;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif


// Connected to PIEIER9_3 (use MINT9 and MG93 masks):
#if (G93PL != 0)
interrupt void SCIRXINTB_ISR(void)     // SCI-B
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG93;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER9_4 (use MINT9 and MG94 masks):
#if (G94PL != 0)
interrupt void SCITXINTB_ISR(void)     // SCI-B
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG94;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
 
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER9_5 (use MINT9 and MG95 masks):
#if (G95PL != 0)
interrupt void ECAN0INTA_ISR(void)    // eCAN-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG95;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER9_6 (use MINT9 and MG96 masks):
#if (G96PL != 0)
interrupt void ECAN1INTA_ISR(void)     // eCAN-A
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG96;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER9_7 (use MINT9 and MG97 masks):
#if (G97PL != 0)
interrupt void ECAN0INTB_ISR(void)    // eCAN-B
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG97;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......

	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// Connected to PIEIER9_8 (use MINT9 and MG98 masks):
#if (G98PL != 0)
interrupt void ECAN1INTB_ISR(void)     // eCAN-B
{
	// Set interrupt priority:
	volatile Uint16 TempPIEIER = PieCtrlRegs.PIEIER9.all;
	IER |= M_INT9;
	IER	&= MINT9;	  	               // Set "global" priority
	PieCtrlRegs.PIEIER9.all &= MG98;   // Set "group"  priority	
	PieCtrlRegs.PIEACK.all = 0xFFFF;   // Enable PIE interrupts	
	EINT;

  	// Insert ISR Code here.......
  
	// Restore registers saved:
	DINT;
	PieCtrlRegs.PIEIER9.all = TempPIEIER;

    // Next two lines for debug only to halt the processor here
    // Remove after inserting ISR Code
    asm ("      ESTOP0");
    for(;;);

}     
#endif

// -----------------------------------------------------------
// PIE Group 10 - MUXed into CPU INT10
// -----------------------------------------------------------
// -----------------------------------------------------------
// PIE Group 11 - MUXed into CPU INT11
// -----------------------------------------------------------
// -----------------------------------------------------------
// PIE Group 12 - MUXed into CPU INT12
// -----------------------------------------------------------

//---------------------------------------------------------------------------
// Catch All Default ISRs: 
//

interrupt void EMPTY_ISR(void)  // Empty ISR - only does a return.
{

}

interrupt void PIE_RESERVED(void)  // Reserved space.  For test.
{
  asm ("      ESTOP0");
  for(;;);
}

interrupt void INT_NOTUSED_ISR(void)  // Reserved space.  For test.
{
  asm ("      ESTOP0");
  for(;;);
}

interrupt void rsvd_ISR(void)      // For test
{
  asm ("      ESTOP0");
  for(;;);
}

//===========================================================================
// No more.
//===========================================================================
DSP280x_SWPrior/1113835038  314   0     0       9653      `
// TI File $Revision: /main/2 $
// Checkin $Date: December 1, 2004   16:21:25 $
//###########################################################################
//
// FILE:   DSP280x_SWPiroritizedPieVect.c
//
// TITLE:  DSP280x Devices SW Prioritized PIE Vector Table Initialization.
//
//###########################################################################
// 
// Original Source by A.T.
//
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################

#include "DSP280x_Device.h"     // DSP280x Headerfile Include File
#include "DSP280x_Examples.h"   // DSP280x Examples Include File
#include "DSP280x_SWPrioritizedIsrLevels.h" 

const struct PIE_VECT_TABLE PieVectTableInit = {

      PIE_RESERVED,       // Reserved space
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved
      PIE_RESERVED,       // reserved

// Non-Peripheral Interrupts:
      #if (INT13PL != 0)
      INT13_ISR,    // XINT13
      #else
      INT_NOTUSED_ISR,
      #endif
      
      #if (INT14PL != 0)
      INT14_ISR,     // CPU-Timer2
      #else
      INT_NOTUSED_ISR,
      #endif
      
      #if (INT15PL != 0)
      DATALOG_ISR,   // Datalogging interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (INT16PL != 0)
      RTOSINT_ISR,   // RTOS interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      rsvd_ISR,      // reserved interrupt
      NMI_ISR,       // Non-maskable interrupt
      ILLEGAL_ISR,   // Illegal operation TRAP
      USER1_ISR,     // User Defined trap 1
      USER2_ISR,     // User Defined trap 2
      USER3_ISR,     // User Defined trap 3
      USER4_ISR,     // User Defined trap 4
      USER5_ISR,     // User Defined trap 5
      USER6_ISR,     // User Defined trap 6
      USER7_ISR,     // User Defined trap 7
      USER8_ISR,     // User Defined trap 8
      USER9_ISR,     // User Defined trap 9
      USER10_ISR,    // User Defined trap 10
      USER11_ISR,    // User Defined trap 11
      USER12_ISR,    // User Defined trap 12

// Group 1 PIE Vectors:
      #if (G11PL != 0)
      SEQ1INT_ISR,   // ADC
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G12PL != 0)
      SEQ2INT_ISR,   // ADC 
      #else
      INT_NOTUSED_ISR,
      #endif

      rsvd_ISR,

      #if (G14PL != 0)
      XINT1_ISR,     // External
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G15PL != 0)
      XINT2_ISR,     // External
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G16PL != 0)
      ADCINT_ISR,    // ADC
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G17PL != 0)
      TINT0_ISR,     // Timer 0
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G18PL != 0)
      WAKEINT_ISR,   // WD & Low Power
      #else
      INT_NOTUSED_ISR,
      #endif

// Group 2 PIE Vectors:
      #if (G21PL != 0)
      EPWM1_TZINT_ISR,   // ePWM1 Trip Zone
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G22PL != 0)
      EPWM2_TZINT_ISR,   // ePWM2 Trip Zone
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G23PL != 0)
      EPWM3_TZINT_ISR,   // ePWM3 Trip Zone
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G24PL != 0)
      EPWM4_TZINT_ISR,   // ePWM4 Trip Zone
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G25PL != 0)
      EPWM5_TZINT_ISR,   // ePWM5 Trip Zone
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G26PL != 0)
      EPWM6_TZINT_ISR,   // ePWM6 Trip Zone
      #else
      INT_NOTUSED_ISR,
      #endif

      rsvd_ISR,
      rsvd_ISR,
      
// Group 3 PIE Vectors:
      #if (G31PL != 0)
      EPWM1_INT_ISR,     // ePWM1 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G32PL != 0)
      EPWM2_INT_ISR,     // ePWM2 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G33PL != 0)
      EPWM3_INT_ISR,     // ePWM3 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G34PL != 0)
      EPWM4_INT_ISR,     // ePWM4 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G35PL != 0)
      EPWM5_INT_ISR,     // ePWM5 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G36PL != 0)
      EPWM6_INT_ISR,     // ePWM6 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      rsvd_ISR,
      rsvd_ISR,
      
// Group 4 PIE Vectors:
      #if (G41PL != 0)
      ECAP1_INT_ISR,     // eCAP1 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G42PL != 0)
      ECAP2_INT_ISR,     // eCAP2 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G43PL != 0)
      ECAP3_INT_ISR,     // eCAP3 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G44PL != 0)
      ECAP4_INT_ISR,     // eCAP4 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      rsvd_ISR,
      rsvd_ISR,
      rsvd_ISR,
      rsvd_ISR,          
     
// Group 5 PIE Vectors:
      #if (G51PL != 0)
      EQEP1_INT_ISR,     // eQEP1 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G52PL != 0)
      EQEP2_INT_ISR,     // eQEP2 Interrupt
      #else
      INT_NOTUSED_ISR,
      #endif

      rsvd_ISR,
      rsvd_ISR,
      rsvd_ISR,
      rsvd_ISR,
      rsvd_ISR,
      rsvd_ISR,            

// Group 6 PIE Vectors:
      #if (G61PL != 0)
      SPIRXINTA_ISR,  // SPI-A
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G62PL != 0)
      SPITXINTA_ISR,  // SPI-A
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G63PL != 0)
      SPIRXINTB_ISR,  // SPI-B
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G64PL != 0)
      SPITXINTB_ISR,  // SPI-B
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G65PL != 0)
      SPIRXINTC_ISR,  // SPI-C
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G66PL != 0)
      SPITXINTC_ISR,  // SPI-C
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G67PL != 0)
      SPIRXINTD_ISR,  // SPI-D
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G68PL != 0)
      SPITXINTD_ISR,  // SPI-D
      #else
      INT_NOTUSED_ISR,
      #endif
      
// Group 7 PIE Vectors:
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     

// Group 8 PIE Vectors:
      #if (G81PL != 0)
      I2CINT1A_ISR,    // I2C-A
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G82PL != 0)
      I2CINT2A_ISR,    // I2C-A
      #else
      INT_NOTUSED_ISR,
      #endif
           
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      
// Group 9 PIE Vectors:
      #if (G91PL != 0)
      SCIRXINTA_ISR,    // SCI-A
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G92PL != 0)
      SCITXINTA_ISR,    // SCI-A
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G93PL != 0)
      SCIRXINTB_ISR,    // SCI-B
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G94PL != 0)
      SCITXINTB_ISR,    // SCI-B
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G95PL != 0)
      ECAN0INTA_ISR,    // eCAN-A
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G96PL != 0)
      ECAN1INTA_ISR,   // eCAN-A
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G97PL != 0)
      ECAN0INTB_ISR,   // eCAN-B
      #else
      INT_NOTUSED_ISR,
      #endif

      #if (G98PL != 0)
      ECAN1INTB_ISR,   // eCAN-B
      #else
      INT_NOTUSED_ISR,
      #endif
      
// Group 10 PIE Vectors
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
            
// Group 11 PIE Vectors
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     

// Group 12 PIE Vectors
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
      rsvd_ISR,     
};

//---------------------------------------------------------------------------
// InitPieVectTable: 
//---------------------------------------------------------------------------
// This function initializes the PIE vector table to a known state.
// This function must be executed after boot time.
//

void InitPieVectTable(void)
{
   int16 i;
   Uint32 *Source = (void *) &PieVectTableInit;
   Uint32 *Dest = (void *) &PieVectTable;

   EALLOW;
   for(i=0; i < 128; i++) {
      *Dest++ = *Source++;
   }
   EDIS;
}

//===========================================================================
// No more.
//===========================================================================

DSP280x_SysCtrl/1137181220  346   0     0       10221     `
// TI File $Revision: /main/3 $
// Checkin $Date: December 8, 2004   14:36:24 $
//###########################################################################
//
// FILE:   DSP280x_SysCtrl.c
//
// TITLE:  DSP280x Device System Control Initialization & Support Functions.
//
// DESCRIPTION:
//
//         Example initialization of system resources.
//
//###########################################################################
// $TI Release: DSP280x V1.10 $
// $Release Date: April 18, 2005 $
//###########################################################################


#include "DSP280x_Device.h"     // Headerfile Include File
#include "DSP280x_Examples.h"   // Examples Include File

// Functions that will be run from RAM need to be assigned to 
// a different section.  This section will then be mapped to a load and 
// run address using the linker cmd file.

#pragma CODE_SECTION(InitFlash, "ramfuncs");

//---------------------------------------------------------------------------
// InitSysCtrl: 
//---------------------------------------------------------------------------
// This function initializes the System Control registers to a known state.
// - Disables the watchdog
// - Set the PLLCR for proper SYSCLKOUT frequency 
// - Set the pre-scaler for the high and low frequency peripheral clocks
// - Enable the clocks to the peripherals

void InitSysCtrl(void)
{

   // Disable the watchdog        
   DisableDog();
   
   // Initialize the PLLCR to 0xA
   InitPll(0xA);

   // Initialize the peripheral clocks
   InitPeripheralClocks();
}


//---------------------------------------------------------------------------
// Example: InitFlash: 
//---------------------------------------------------------------------------
// This function initializes the Flash Control registers

//                   CAUTION 
// This function MUST be executed out of RAM. Executing it
// out of OTP/Flash will yield unpredictable results

void InitFlash(void)
{
   EALLOW;
   //Enable Flash Pipeline mode to improve performance
   //of code executed from Flash.
   FlashRegs.FOPT.bit.ENPIPE = 1;
   
   //                CAUTION
   //Minimum waitstates required for the flash operating
   //at a given CPU rate must be characterized by TI. 
   //Refer to the datasheet for the latest information.  

   //Set the Random Waitstate for the Flash
   FlashRegs.FBANKWAIT.bit.RANDWAIT = 5;
   
   //Set the Paged Waitstate for the Flash
   FlashRegs.FBANKWAIT.bit.PAGEWAIT = 5;

   //Set the Waitstate for the OTP
   FlashRegs.FOTPWAIT.bit.OTPWAIT = 8;
   
   //                CAUTION
   //Minimum cycles required to move between power states
   //at a given CPU rate must be characterized by TI. 
   //Refer to the datasheet for the latest information.
     
   //For now use the default count
   //Set number of cycles to transition from sleep to standby
   FlashRegs.FSTDBYWAIT.bit.STDBYWAIT = 0x01FF;       
   
   //Set number of cycles to transition from standby to active
   FlashRegs.FACTIVEWAIT.bit.ACTIVEWAIT = 0x01FF;   
   EDIS;

   //Force a pipeline flush to ensure that the write to 
   //the last register configured occurs before returning.  

   asm(" RPT #7 || NOP");
}	


//---------------------------------------------------------------------------
// Example: KickDog: 
//---------------------------------------------------------------------------
// This function resets the watchdog timer.
// Enable this function for using KickDog in the application 

void KickDog(void)
{
    EALLOW;
    SysCtrlRegs.WDKEY = 0x0055;
    SysCtrlRegs.WDKEY = 0x00AA;
    EDIS;
}

//---------------------------------------------------------------------------
// Example: DisableDog: 
//---------------------------------------------------------------------------
// This function disables the watchdog timer.

void DisableDog(void)
{
    EALLOW;
    SysCtrlRegs.WDCR= 0x0068;
    EDIS;
}

//---------------------------------------------------------------------------
// Example: InitPll: 
//---------------------------------------------------------------------------
// This function initializes the PLLCR register.

void InitPll(Uint16 val)
{
   volatile Uint16 iVol;   
   
   // Make sure the PLL is not running in limp mode
   if (SysCtrlRegs.PLLSTS.bit.MCLKSTS != 1)
   {
       if (SysCtrlRegs.PLLCR.bit.DIV != val)
       {
   
          
          EALLOW;
          // Before setting PLLCR turn off missing clock detect
          SysCtrlRegs.PLLSTS.bit.MCLKOFF = 1;
          SysCtrlRegs.PLLCR.bit.DIV = val;
          EDIS;
   
          // Optional: Wait for PLL to lock.
          // During this time the CPU will switch to OSCCLK/2 until
          // the PLL is stable.  Once the PLL is stable the CPU will 
          // switch to the new PLL value. 
          //
          // This time-to-lock is monitored by a PLL lock counter.   
          //   
          // Code is not required to sit and wait for the PLL to lock.   
          // However, if the code does anything that is timing critical, 
          // and requires the correct clock be locked, then it is best to 
          // wait until this switching has completed.  
   
          // The watchdog should be disabled before this loop, or fed within 
          // the loop.   
   
          DisableDog();
   
          // Wait for the PLL lock bit to be set.  
          // Note this bit is not available on 281x devices.  For those devices
          // use a software loop to perform the required count. 
   
          while(SysCtrlRegs.PLLSTS.bit.PLLLOCKS != 1) { }
          
          EALLOW;
          SysCtrlRegs.PLLSTS.bit.MCLKOFF = 0;
          EDIS;
       }
   }
   
   // If the PLL is in limp mode, shut the system down
   else 
   {
      // Replace this line with a call to an appropriate
      // SystemShutdown(); function. 
      asm("        ESTOP0");
   }
}

//--------------------------------------------------------------------------
// Example: InitPeripheralClocks: 
//---------------------------------------------------------------------------
// This function initializes the clocks to the peripheral modules.
// First the high and low clock prescalers are set
// Second the clocks are enabled to each peripheral.
// To reduce power, leave clocks to unused peripherals disabled
//
// Note: If a peripherals clock is not enabled then you cannot 
// read or write to the registers for that peripheral 

void InitPeripheralClocks(void)
{ 
   EALLOW;
// HISPCP/LOSPCP prescale register settings, normally it will be set to default values
   SysCtrlRegs.HISPCP.all = 0x0001;
   SysCtrlRegs.LOSPCP.all = 0x0002;

   SysCtrlRegs.XCLK.bit.XCLKOUTDIV=2;
      	
// Peripheral clock enables set for the selected peripherals.   
// If you are not using a peripheral you may want to leave
// the clock off to save on power. 
// 
  
	SysCtrlRegs.PCLKCR0.bit.ECANBENCLK	=1;    // eCAN-B
	SysCtrlRegs.PCLKCR0.bit.ECANAENCLK	=1;    // eCAN-A
	SysCtrlRegs.PCLKCR0.bit.rsvd3 		=0;
	SysCtrlRegs.PCLKCR0.bit.SCIBENCLK	=1;     // SCI-B
	SysCtrlRegs.PCLKCR0.bit.SCIAENCLK	=1;     // SCI-A
	SysCtrlRegs.PCLKCR0.bit.SPICENCLK	=1;     // SPI-C
	SysCtrlRegs.PCLKCR0.bit.SPIBENCLK	=1;     // SPI-B
	SysCtrlRegs.PCLKCR0.bit.SPIAENCLK	=1;     // SPI-A
	SysCtrlRegs.PCLKCR0.bit.SPIDENCLK	=1;     // SPI-D
	SysCtrlRegs.PCLKCR0.bit.rsvd2 		=0;
	SysCtrlRegs.PCLKCR0.bit.I2CAENCLK 	=1;   // I2C
	SysCtrlRegs.PCLKCR0.bit.ADCENCLK 	=1;    // ADC
	SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC 	=0;	// TBCLKSYNC default
	SysCtrlRegs.PCLKCR0.bit.rsvd1 		=0;
	
	
	
	SysCtrlRegs.PCLKCR0.all = 0x3214;
	
	
	

// Note: not all peripherals are available on all 280x derivates.
// Refer to the datasheet for your particular device. 
 	{
 	union PCLKCR0_REG regPCLKCR0;
	regPCLKCR0.bit.ECANBENCLK	=1;    // eCAN-B
	regPCLKCR0.bit.ECANAENCLK	=1;    // eCAN-A
	regPCLKCR0.bit.rsvd3 		=0;
	regPCLKCR0.bit.SCIBENCLK	=1;     // SCI-B
	regPCLKCR0.bit.SCIAENCLK	=1;     // SCI-A
	regPCLKCR0.bit.SPICENCLK	=1;     // SPI-C
	regPCLKCR0.bit.SPIBENCLK	=0;     // SPI-B
	regPCLKCR0.bit.SPIAENCLK	=1;     // SPI-A
	regPCLKCR0.bit.SPIDENCLK	=1;     // SPI-D
	regPCLKCR0.bit.rsvd2 		=0;
	regPCLKCR0.bit.I2CAENCLK 	=1;   // I2C
	regPCLKCR0.bit.ADCENCLK 	=1;    // ADC
	regPCLKCR0.bit.TBCLKSYNC 	=0;	// TBCLKSYNC default
	regPCLKCR0.bit.rsvd1 		=0;
	SysCtrlRegs.PCLKCR0.all = regPCLKCR0.all;
	}


 	{
 	union PCLKCR0_REG regPCLKCR0;
	regPCLKCR0.bit.ECANBENCLK	=1;    // eCAN-B
	regPCLKCR0.bit.ECANAENCLK	=1;    // eCAN-A
	regPCLKCR0.bit.rsvd3 		=0;
	regPCLKCR0.bit.SCIBENCLK	=1;     // SCI-B
	regPCLKCR0.bit.SPIAENCLK	=1;     // SPI-A
	regPCLKCR0.bit.SPIDENCLK	=1;     // SPI-D
	regPCLKCR0.bit.rsvd2 		=0;
	regPCLKCR0.bit.I2CAENCLK 	=1;   // I2C
	regPCLKCR0.bit.ADCENCLK 	=1;    // ADC
	regPCLKCR0.bit.TBCLKSYNC 	=0;	// TBCLKSYNC default
	//regPCLKCR0.bit.rsvd1 		=0;
	
		regPCLKCR0.bit.SCIAENCLK	=1;     // SCI-A
	regPCLKCR0.bit.SPICENCLK	=1;     // SPI-C
	regPCLKCR0.bit.SPIBENCLK	=1;     // SPI-B


	SysCtrlRegs.PCLKCR0.all = regPCLKCR0.all;
	}



   
   SysCtrlRegs.PCLKCR1.bit.ECAP1ENCLK = 1;  // eCAP1
   SysCtrlRegs.PCLKCR1.bit.ECAP2ENCLK = 1;  // eCAP2
   SysCtrlRegs.PCLKCR1.bit.ECAP3ENCLK = 1;  // eCAP3
   SysCtrlRegs.PCLKCR1.bit.ECAP4ENCLK = 1;  // eCAP4
   
   SysCtrlRegs.PCLKCR1.bit.EPWM1ENCLK = 1;  // ePWM1
   SysCtrlRegs.PCLKCR1.bit.EPWM2ENCLK = 1;  // ePWM2
   SysCtrlRegs.PCLKCR1.bit.EPWM3ENCLK = 1;  // ePWM3
   SysCtrlRegs.PCLKCR1.bit.EPWM4ENCLK = 1;  // ePWM4
   SysCtrlRegs.PCLKCR1.bit.EPWM5ENCLK = 1;  // ePWM5
   SysCtrlRegs.PCLKCR1.bit.EPWM6ENCLK = 1;  // ePWM6

   SysCtrlRegs.PCLKCR0.bit.TBCLKSYNC = 1;   // Enable TBCLK within the ePWM
   
   SysCtrlRegs.PCLKCR1.bit.EQEP1ENCLK = 1;  // eQEP1
   SysCtrlRegs.PCLKCR1.bit.EQEP2ENCLK = 1;  // eQEP2
                        
   EDIS;
}

	
//===========================================================================
// End of file.
//===========================================================================
